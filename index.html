<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oppskrifts Admin</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
        }
        .datalist-input::-webkit-calendar-picker-indicator {
            display: none;
        }
        /* Custom scrollbar */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #d4d4d4;
            border-radius: 3px;
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        .notification {
            animation: slideIn 0.3s ease-out;
        }
        .notification.hiding {
            animation: slideOut 0.3s ease-out;
        }
        /* Image loading animation */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: .5;
            }
        }
        .image-loading {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        /* Radio button styling */
        .sort-radio {
            display: none;
        }
        .sort-label {
            padding: 0.375rem 0.75rem;
            border: 1px solid #d1d5db;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }
        .sort-label:first-of-type {
            border-radius: 0.375rem 0 0 0.375rem;
        }
        .sort-label:last-of-type {
            border-radius: 0 0.375rem 0.375rem 0;
        }
        .sort-radio:checked + .sort-label {
            background: rgb(251 191 36);
            color: white;
            border-color: rgb(245 158 11);
        }
        .sort-label:hover {
            background: #f9fafb;
        }
        .sort-radio:checked + .sort-label:hover {
            background: rgb(245 158 11);
        }
        /* Custom checkbox styling */
        .custom-checkbox {
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid #d1d5db;
            border-radius: 0.25rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .custom-checkbox:checked {
            background-color: rgb(239 68 68);
            border-color: rgb(239 68 68);
        }
        .custom-checkbox:checked::after {
            content: '‚úì';
            position: absolute;
            color: white;
            font-size: 0.875rem;
            font-weight: bold;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .custom-checkbox:hover {
            border-color: rgb(156 163 175);
        }
        .custom-checkbox:checked:hover {
            background-color: rgb(220 38 38);
            border-color: rgb(220 38 38);
        }
        /* Taxonomy modal specific styles */
        .taxonomy-value-item {
            transition: background-color 0.2s;
        }
        .taxonomy-value-item:hover {
            background-color: #f9fafb;
        }
        .taxonomy-recipes-list {
            max-height: 200px;
            overflow-y: auto;
        }
        .taxonomy-change {
            background-color: #fef3c7;
            border-left: 3px solid #f59e0b;
        }
    </style>
</head>
<body class="bg-gray-50 h-full">
    <!-- Notification Container -->
    <div id="notificationContainer" class="fixed top-4 right-4 z-50 space-y-2 pointer-events-none">
        <!-- Notifications will be inserted here -->
    </div>

    <!-- Taxonomy Modal -->
    <div id="taxonomyModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] flex flex-col">
            <div class="p-6 border-b flex-shrink-0">
                <h3 class="text-lg font-bold text-gray-800 mb-4">Organiser Taksonomi</h3>
                
                <div class="flex gap-4 items-center">
                    <select id="taxonomyFieldSelect" class="px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                        <option value="">Velg felt...</option>
                        <option value="provider">Person (oppskrift fra)</option>
                        <option value="reference">Kilde</option>
                        <option value="category">Kategori</option>
                        <option value="meal">M√•ltid</option>
                        <option value="cuisine">Kj√∏kken</option>
                    </select>
                    
                    <div id="taxonomyStats" class="text-sm text-gray-600"></div>
                </div>
            </div>
            
            <div class="flex-1 min-h-0 overflow-y-auto p-6">
                <div id="taxonomyPendingChanges" class="hidden mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                    <p class="text-sm font-medium text-yellow-800">Ventende endringer:</p>
                    <ul id="taxonomyChangesList" class="text-sm text-yellow-700 mt-2 space-y-1"></ul>
                </div>
                
                <div id="taxonomyContent" class="space-y-2">
                    <!-- Content will be populated here -->
                </div>
                
                <div id="taxonomyPagination" class="hidden mt-4 flex justify-center gap-2">
                    <!-- Pagination will be populated here -->
                </div>
            </div>
            
            <div class="p-6 border-t flex justify-between items-center flex-shrink-0">
                <button onclick="app.taxonomyManager.resetChanges()" id="taxonomyResetBtn" disabled
                        class="px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 disabled:opacity-50 disabled:cursor-not-allowed transition">
                    <i class="fas fa-undo mr-2"></i>Tilbakestill endringer
                </button>
                <div class="flex gap-2">
                    <button onclick="app.taxonomyManager.closeModal()" 
                            class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">
                        Avbryt
                    </button>
                    <button onclick="app.taxonomyManager.saveChanges()" id="taxonomySaveBtn" disabled
                            class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition">
                        <i class="fas fa-save mr-2"></i>Lagre endringer
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="importModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg max-w-md w-full p-6">
            <h3 class="text-lg font-bold text-gray-800 mb-4">Importer oppskrifter</h3>
            
            <div class="mb-4">
                <p class="text-sm text-gray-600 mb-3">Velg en JSON-fil med oppskrifter √• importere.</p>
                
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
                    <label class="flex items-start gap-3 cursor-pointer">
                        <input type="checkbox" id="deleteExistingRecipes" class="custom-checkbox mt-0.5">
                        <div>
                            <span class="font-medium text-gray-800">Slett alle eksisterende oppskrifter</span>
                            <p class="text-xs text-gray-600 mt-1">
                                ‚ö†Ô∏è Dette vil permanent slette alle n√•v√¶rende oppskrifter f√∏r import.
                                Hvis avsl√•tt, vil oppskrifter med samme ID bli overskrevet.
                            </p>
                        </div>
                    </label>
                </div>
                
                <input type="file" id="importFileInput" accept=".json" class="hidden">
                <button onclick="app.importExportManager.selectImportFile()" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                    üìÇ Velg fil
                </button>
                <p id="selectedFileName" class="text-sm text-gray-500 mt-2 text-center"></p>
            </div>
            
            <div class="flex gap-2">
                <button onclick="app.importExportManager.closeImportModal()" 
                        class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">
                    Avbryt
                </button>
                <button onclick="app.importExportManager.performImport()" id="confirmImportBtn" disabled
                        class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition">
                    Importer
                </button>
            </div>
        </div>
    </div>

    <!-- Main Layout Container -->
    <div class="h-full flex flex-col">
        <!-- Header - Fixed height -->
        <header class="bg-white shadow-sm border-b flex-shrink-0">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                <div class="flex justify-between items-center">
                    <h1 class="text-2xl font-bold text-gray-800">Oppskrifts Admin</h1>
                    <div class="flex gap-2">
                        <button onclick="app.templateManager.copyTemplate()" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition">
                            üìã Kopier Mal
                        </button>
                        
                        <div class="relative">
                            <button onclick="app.importExportManager.toggleExportMenu()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition">
                                üì§ Eksporter ‚ñº
                            </button>
                            <div id="exportMenu" class="hidden absolute right-0 mt-2 bg-white border border-gray-300 rounded-lg shadow-lg z-10">
                                <div class="px-4 py-2 border-b bg-gray-50">
                                    <label class="flex items-center gap-2 text-sm cursor-pointer">
                                        <input type="checkbox" id="convertPngToJpg" checked class="rounded">
                                        <span class="text-gray-700">üîÑ Konverter .png til .jpg</span>
                                    </label>
                                </div>
                                <button onclick="app.importExportManager.exportDatabase('file')" class="w-full text-left px-4 py-2 hover:bg-gray-100 border-b">
                                    üíæ Eksporter til fil
                                </button>
                                <button onclick="app.importExportManager.exportDatabase('clipboard')" class="w-full text-left px-4 py-2 hover:bg-gray-100">
                                    üìã Kopier til utklippstavle
                                </button>
                            </div>
                        </div>
                        
                        <button onclick="app.importExportManager.openImportModal()" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                            üì• Importer
                        </button>
                        
                        <button onclick="app.taxonomyManager.openModal()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">
                            üè∑Ô∏è Taksonomi
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content Area - Takes remaining space -->
        <div class="flex-1 min-h-0 max-w-7xl w-full mx-auto px-4 sm:px-6 lg:px-8">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 h-full min-h-0">
                <!-- Recipe List -->
                <div class="lg:col-span-1 h-full py-6 min-h-0">
                    <div class="bg-white rounded-lg shadow-md h-full flex flex-col min-h-0">
                        <div class="flex-shrink-0 p-4 border-b border-gray-100">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-lg font-semibold text-gray-700">Oppskrifter</h2>
                                <span class="text-sm text-gray-500" id="recipeCount">0 oppskrifter</span>
                            </div>
                            
                            <!-- Filter button and dropdown -->
                            <div class="mb-3 relative">
                                <button id="filterMenuBtn" onclick="app.filterManager.toggleFilterMenu()" 
                                        class="w-full px-3 py-2 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition flex items-center justify-between">
                                    <span class="flex items-center gap-2">
                                        <i class="fas fa-filter text-gray-600"></i>
                                        <span class="text-sm">Filter</span>
                                        <span id="filterIndicator" class="hidden text-xs text-blue-600 font-medium"></span>
                                    </span>
                                    <i class="fas fa-chevron-down text-gray-400 text-xs"></i>
                                </button>
                                
                                <div id="filterDropdown" class="hidden absolute top-full left-0 right-0 mt-1 bg-white border border-gray-300 rounded-lg shadow-lg z-20 max-h-96 overflow-y-auto">
                                    <div id="filterOptionsContainer">
                                        <!-- Filter options will be populated here -->
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Sorting Options -->
                            <div class="mb-3 flex justify-center">
                                <div class="inline-flex text-xs">
                                    <input type="radio" id="sortAlpha" name="sortOrder" value="alphabetical" class="sort-radio" onchange="app.recipeManager.changeSortOrder('alphabetical')" checked>
                                    <label for="sortAlpha" class="sort-label">A-√Ö</label>
                                    
                                    <input type="radio" id="sortPerson" name="sortOrder" value="person" class="sort-radio" onchange="app.recipeManager.changeSortOrder('person')">
                                    <label for="sortPerson" class="sort-label">Person</label>
                                    
                                    <input type="radio" id="sortSource" name="sortOrder" value="source" class="sort-radio" onchange="app.recipeManager.changeSortOrder('source')">
                                    <label for="sortSource" class="sort-label">Kilde</label>
                                    
                                    <input type="radio" id="sortDate" name="sortOrder" value="date" class="sort-radio" onchange="app.recipeManager.changeSortOrder('date')">
                                    <label for="sortDate" class="sort-label">Dato</label>
                                </div>
                            </div>
                            
                            <button onclick="app.formManager.clearForm()" class="w-full px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600 transition">
                                <i class="fas fa-plus mr-2"></i>Ny oppskrift
                            </button>
                        </div>
                        
                        <!-- Scrollable recipe list -->
                        <div class="flex-1 min-h-0 overflow-y-auto overscroll-contain">
                            <div id="recipeList" class="custom-scroll p-4 pt-2 space-y-2">
                                <!-- Recipe items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>
        
                <!-- Recipe Form -->
                <div class="lg:col-span-2 h-full py-6 min-h-0">
                    <div class="bg-white rounded-lg shadow-md h-full flex flex-col min-h-0">
                        <!-- Fixed header section -->
                        <div class="flex-shrink-0 px-6 pt-6 pb-4 border-b border-gray-100">
                            <!-- JSON Paste Area -->
                            <div class="mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                                <label class="block text-sm font-medium text-gray-700 mb-2">
                                    Lim inn JSON oppskrift (valgfritt)
                                </label>
                                <textarea id="jsonPaste" rows="3" placeholder='Lim inn JSON objekt her, f.eks: {"title": "Pasta", "servings": "4 porsjoner"...}'
                                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm font-mono resize-y"></textarea>
                                <div class="flex gap-2 mt-2">
                                    <button onclick="app.formManager.parseJsonInput()" class="px-3 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-700 transition">
                                        Parse JSON ‚Üí Fyll skjema
                                    </button>
                                    <button onclick="app.formManager.processMultipleRecipes()" class="px-3 py-1 bg-orange-600 text-white text-sm rounded hover:bg-orange-700 transition">
                                        üîÑ Multi-oppskrift parsing
                                    </button>
                                    <button onclick="app.formManager.exportFormToClipboard()" class="px-3 py-1 bg-indigo-600 text-white text-sm rounded hover:bg-indigo-700 transition">
                                        üìã Kopier som JSON
                                    </button>
                                    <button onclick="app.formManager.exportFormToClipboardCompact()" class="px-3 py-1 bg-indigo-500 text-white text-sm rounded hover:bg-indigo-600 transition">
                                        üìÑ Kopier som 1 rads JSON
                                    </button>
                                </div>
                            </div>
        
                            <div class="flex justify-between items-center">
                                <h2 class="text-xl font-semibold text-gray-700">Oppskrift Detaljer</h2>
                                <div class="flex gap-2">
                                    <button onclick="app.historyManager.undo()" id="undoBtn" disabled class="px-3 py-1 rounded-lg bg-gray-200 text-gray-600 hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed transition">
                                        <i class="fas fa-undo"></i>
                                    </button>
                                    <button onclick="app.historyManager.redo()" id="redoBtn" disabled class="px-3 py-1 rounded-lg bg-gray-200 text-gray-600 hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed transition">
                                        <i class="fas fa-redo"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Scrollable form content -->
                        <div class="flex-1 min-h-0 overflow-y-auto overscroll-contain">
                            <div id="recipeFormContainer" class="custom-scroll p-6 pt-4">
                                <form id="recipeForm" class="space-y-4">
                                    <!-- Hidden ID field -->
                                    <input type="hidden" id="recipeId">
                                    
                                    <!-- Title -->
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Tittel *</label>
                                        <input type="text" id="title" required onchange="app.historyManager.saveToHistory()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                        <div class="flex items-center gap-2 mt-1">
                                            <p id="recipeIdDisplay" class="text-xs text-gray-500"></p>
                                            <button type="button" id="regenerateIdBtn" onclick="app.formManager.regenerateId()" class="hidden text-gray-400 hover:text-gray-600 transition" title="Generer ny ID">
                                                <i class="fas fa-sync-alt text-xs"></i>
                                            </button>
                                        </div>
                                    </div>
        
                                    <!-- Provider and Reference with Page Number -->
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">Oppskrift fra</label>
                                            <input type="text" id="provider" placeholder="F.eks: Bestemor" onchange="app.historyManager.saveToHistory()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                        </div>
                                        <div class="grid grid-cols-3 gap-2">
                                            <div class="col-span-2">
                                                <label class="block text-sm font-medium text-gray-700 mb-1">Kilde</label>
                                                <input type="text" id="reference" placeholder="F.eks: Farmors bok" onchange="app.historyManager.saveToHistory()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700 mb-1">Side</label>
                                                <input type="number" id="pageNumber" placeholder="45" min="1" onchange="app.historyManager.saveToHistory()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                            </div>
                                        </div>
                                    </div>
        
                                    <!-- Servings -->
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Porsjoner *</label>
                                        <input type="text" id="servings" required placeholder="F.eks: 4 porsjoner" onchange="app.historyManager.saveToHistory()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                    </div>
        
                                    <!-- Category, Meal, Cuisine -->
                                    <div class="grid grid-cols-3 gap-4">
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">Kategori</label>
                                            <input type="text" id="category" list="categoryList" onchange="app.historyManager.saveToHistory()" class="datalist-input w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                            <datalist id="categoryList"></datalist>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">M√•ltid</label>
                                            <input type="text" id="meal" list="mealList" onchange="app.historyManager.saveToHistory()" class="datalist-input w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                            <datalist id="mealList"></datalist>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium text-gray-700 mb-1">Kj√∏kken</label>
                                            <input type="text" id="cuisine" list="cuisineList" onchange="app.historyManager.saveToHistory()" class="datalist-input w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                            <datalist id="cuisineList"></datalist>
                                        </div>
                                    </div>
        
                                    <!-- Description -->
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Beskrivelse</label>
                                        <textarea id="description" rows="3" onchange="app.historyManager.saveToHistory()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 resize-y"></textarea>
                                    </div>
        
                                    <!-- Image Filename -->
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">
                                            Bildefil
                                            <button type="button" onclick="app.templateManager.exportImagePrompt()" class="text-xs text-indigo-600 hover:underline ml-2">
                                                üé® Eksporter bildeprompt ‚Üí
                                            </button>
                                        </label>
                                        <div class="flex gap-2">
                                            <input type="text" id="image" placeholder="bilde.jpg eller oppskrift-navn.png" 
                                                oninput="app.imageManager.updateImagePreview()"
                                                onchange="app.historyManager.saveToHistory()"
                                                class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                            <button type="button" onclick="app.imageManager.refreshImage()" title="Last inn bilde p√• nytt" 
                                                class="px-3 py-2 border border-gray-300 rounded-md hover:bg-gray-50 transition">
                                                <i class="fas fa-sync-alt text-gray-600"></i>
                                            </button>
                                        </div>
                                        
                                        <!-- Image Preview Container -->
                                        <div id="imagePreviewContainer" class="mt-3">
                                            <!-- Loading state -->
                                            <div id="imageLoadingState" class="hidden border rounded-lg p-8 bg-gray-50">
                                                <div class="flex flex-col items-center justify-center text-gray-500">
                                                    <i class="fas fa-spinner fa-spin text-2xl mb-2"></i>
                                                    <p class="text-sm">Laster bilde...</p>
                                                </div>
                                            </div>
                                            
                                            <!-- Error state -->
                                            <div id="imageErrorState" class="hidden border border-red-200 rounded-lg p-4 bg-red-50">
                                                <div class="flex items-start gap-3">
                                                    <i class="fas fa-exclamation-triangle text-red-500 mt-0.5"></i>
                                                    <div class="flex-1">
                                                        <p class="text-sm font-medium text-red-800">Kunne ikke laste bilde</p>
                                                        <p id="imageErrorMessage" class="text-xs text-red-600 mt-1"></p>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <!-- Success state -->
                                            <div id="imageSuccessState" class="hidden">
                                                <div class="border rounded-lg overflow-hidden bg-gray-50">
                                                    <img id="imagePreview" src="" alt="Forh√•ndsvisning" class="w-full max-h-[200px] object-cover object-center">
                                                </div>
                                                <p class="text-xs text-gray-500 mt-1">Bildeforh√•ndsvisning</p>
                                            </div>
                                        </div>
                                    </div>
        
                                    <!-- Ingredients -->
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">
                                            Ingredienser 
                                            <span class="text-xs text-gray-500">(√©n per linje, skill grupper med "---Gruppenavn---", avslutt gruppe med "---")</span>
                                        </label>
                                        <textarea id="ingredients" rows="6" 
                                            placeholder="500 g mel&#10;2 dl melk&#10;---Fyll---&#10;100 g sukker&#10;2 ss kanel&#10;---&#10;1 egg til pensling" 
                                            onchange="app.historyManager.saveToHistory()"
                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 font-mono text-sm resize-y"></textarea>
                                    </div>
        
                                    <!-- Instructions -->
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">
                                            Fremgangsm√•te 
                                            <span class="text-xs text-gray-500">(√©n per linje, skill grupper med "---Gruppenavn---", avslutt gruppe med "---")</span>
                                        </label>
                                        <textarea id="instructions" rows="6" 
                                            placeholder="Bland de t√∏rre ingrediensene&#10;Tilsett melk og egg&#10;---Steking---&#10;Forvarm ovnen til 180¬∞C&#10;Stek i 25 minutter&#10;---&#10;Server varm med sm√∏r" 
                                            onchange="app.historyManager.saveToHistory()"
                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 resize-y"></textarea>
                                    </div>
                                </form>
                            </div>
                        </div>
                        
                        <!-- Fixed footer section -->
                        <div class="flex-shrink-0 p-6 pt-4 border-t border-gray-100">
                            <div class="flex justify-between">
                                <button type="button" onclick="app.uiManager.previewRecipe()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">
                                    üëÅ Forh√•ndsvis
                                </button>
                                <div class="flex gap-2">
                                    <button type="button" onclick="app.recipeManager.deleteRecipe()" id="deleteBtn" class="hidden px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">
                                        üóë Slett
                                    </button>
                                    <button type="submit" form="recipeForm" class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-medium">
                                        üíæ Lagre
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Preview Modal -->
    <div id="previewModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg max-w-3xl w-full relative overflow-y-auto" style="max-height: 90vh;">
            <!-- Close button inside modal -->
            <button onclick="app.uiManager.closePreview()" class="absolute top-4 right-4 bg-gray-100 rounded-full p-2 hover:bg-gray-200 z-10">
                <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
            <div class="p-6">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 pr-12">Forh√•ndsvisning</h2>
                <div id="previewContent" class="space-y-4">
                    <!-- Preview content will be inserted here -->
                </div>
            </div>
        </div>
    </div>

<script>
// Configuration class
class Config {
    static IMAGE_PATHS = {
        'png': 'images/full/',
        'jpg': 'images/low/',
        'default': 'images/low/'
    };
    
    static DEFAULT_CATEGORIES = [];
    static DEFAULT_MEALS = [];
    static DEFAULT_CUISINES = [];
}

class FilterManager {
    constructor() {
        this.activeFilters = {
            provider: new Set(),
            reference: new Set(),
            category: new Set(),
            meal: new Set(),
            cuisine: new Set()
        };
        this.expandedFilterTypes = new Set();
        this.filterMenuOpen = false;
        this.closeHandler = null; // Store the handler reference
    }

    toggleFilterMenu() {
        const menu = document.getElementById('filterDropdown');
        this.filterMenuOpen = !this.filterMenuOpen;
        
        if (this.filterMenuOpen) {
            menu.classList.remove('hidden');
            this.renderFilterOptions();
            
            // Create and store the close handler
            this.closeHandler = (e) => this.handleOutsideClick(e);
            
            // Add the event listener after a delay to prevent immediate closing
            setTimeout(() => {
                document.addEventListener('click', this.closeHandler, true);
            }, 10);
        } else {
            this.closeFilterMenu();
        }
    }

    closeFilterMenu() {
        const menu = document.getElementById('filterDropdown');
        menu.classList.add('hidden');
        this.filterMenuOpen = false;
        
        // Remove the event listener if it exists
        if (this.closeHandler) {
            document.removeEventListener('click', this.closeHandler, true);
            this.closeHandler = null;
        }
    }

    handleOutsideClick(e) {
        const menu = document.getElementById('filterDropdown');
        const button = document.getElementById('filterMenuBtn');
        
        // Check if click is on the button or inside the dropdown
        if (!button.contains(e.target) && !menu.contains(e.target)) {
            this.closeFilterMenu();
        }
    }

    toggleFilterType(type) {
        if (this.expandedFilterTypes.has(type)) {
            this.expandedFilterTypes.delete(type);
        } else {
            this.expandedFilterTypes.add(type);
        }
        this.renderFilterOptions();
    }

    getUniqueValuesForField(field) {
        const values = new Set();
        Object.values(app.recipeManager.recipeDatabase).forEach(recipe => {
            if (recipe[field]) {
                values.add(recipe[field]);
            }
        });
        return Array.from(values).sort();
    }

    toggleFilter(field, value, event) {
        // Prevent event from bubbling up
        if (event) {
            event.stopPropagation();
        }
        
        if (this.activeFilters[field].has(value)) {
            this.activeFilters[field].delete(value);
        } else {
            this.activeFilters[field].add(value);
        }
        
        // Update recipe list
        app.uiManager.renderRecipeList();
        
        // Update filter indicator
        this.updateFilterIndicator();
        
        // Re-render filter options to update the UI
        this.renderFilterOptions();
    }

    clearAllFilters() {
        Object.keys(this.activeFilters).forEach(key => {
            this.activeFilters[key].clear();
        });
        app.uiManager.renderRecipeList();
        this.updateFilterIndicator();
        this.renderFilterOptions();
    }

    clearFieldFilters(field, event) {
        if (event) {
            event.stopPropagation();
        }
        this.activeFilters[field].clear();
        app.uiManager.renderRecipeList();
        this.updateFilterIndicator();
        this.renderFilterOptions();
    }

    updateFilterIndicator() {
        const indicator = document.getElementById('filterIndicator');
        let totalActive = 0;
        Object.values(this.activeFilters).forEach(set => {
            totalActive += set.size;
        });
        
        if (totalActive > 0) {
            indicator.textContent = `(${totalActive})`;
            indicator.classList.remove('hidden');
        } else {
            indicator.classList.add('hidden');
        }
    }

    renderFilterOptions() {
        const container = document.getElementById('filterOptionsContainer');
        container.innerHTML = '';
        
        // Add clear all button if there are active filters
        let hasActiveFilters = false;
        Object.values(this.activeFilters).forEach(set => {
            if (set.size > 0) hasActiveFilters = true;
        });
        
        if (hasActiveFilters) {
            const clearAllBtn = document.createElement('div');
            clearAllBtn.className = 'px-4 py-2 bg-red-50 border-b text-sm';
            clearAllBtn.innerHTML = `
                <button class="text-red-600 hover:text-red-800 font-medium">
                    <i class="fas fa-times-circle mr-1"></i>Fjern alle filtre
                </button>
            `;
            clearAllBtn.onclick = (e) => {
                e.stopPropagation();
                this.clearAllFilters();
            };
            container.appendChild(clearAllBtn);
        }
        
        const fields = [
            { key: 'provider', label: 'Person', icon: 'üë§' },
            { key: 'reference', label: 'Kilde', icon: 'üìñ' },
            { key: 'category', label: 'Kategori', icon: 'üè∑Ô∏è' },
            { key: 'meal', label: 'M√•ltid', icon: 'üçΩÔ∏è' },
            { key: 'cuisine', label: 'Kj√∏kken', icon: 'üåç' }
        ];
        
        fields.forEach(field => {
            const values = this.getUniqueValuesForField(field.key);
            if (values.length === 0) return;
            
            const isExpanded = this.expandedFilterTypes.has(field.key);
            const activeCount = this.activeFilters[field.key].size;
            
            // Field header
            const fieldHeader = document.createElement('div');
            fieldHeader.className = 'px-4 py-2 hover:bg-gray-50 cursor-pointer border-b flex items-center justify-between';
            fieldHeader.onclick = (e) => {
                e.stopPropagation();
                this.toggleFilterType(field.key);
            };
            
            const headerLeft = document.createElement('div');
            headerLeft.className = 'flex items-center gap-2';
            headerLeft.innerHTML = `
                <span>${field.icon}</span>
                <span class="font-medium text-sm">${field.label}</span>
                ${activeCount > 0 ? `<span class="text-xs bg-blue-100 text-blue-600 px-2 py-0.5 rounded">${activeCount}</span>` : ''}
            `;
            
            const headerRight = document.createElement('div');
            headerRight.className = 'flex items-center gap-2';
            
            if (activeCount > 0) {
                const clearBtn = document.createElement('button');
                clearBtn.className = 'text-xs text-red-600 hover:text-red-800';
                clearBtn.innerHTML = '<i class="fas fa-times"></i>';
                clearBtn.onclick = (e) => {
                    e.stopPropagation();
                    this.clearFieldFilters(field.key, e);
                };
                headerRight.appendChild(clearBtn);
            }
            
            const chevron = document.createElement('i');
            chevron.className = `fas fa-chevron-${isExpanded ? 'down' : 'right'} text-gray-400 text-xs`;
            headerRight.appendChild(chevron);
            
            fieldHeader.appendChild(headerLeft);
            fieldHeader.appendChild(headerRight);
            container.appendChild(fieldHeader);
            
            // Field values (if expanded)
            if (isExpanded) {
                const valuesContainer = document.createElement('div');
                valuesContainer.className = 'bg-gray-50 max-h-48 overflow-y-auto';
                
                values.forEach(value => {
                    const isActive = this.activeFilters[field.key].has(value);
                    
                    const valueItem = document.createElement('div');
                    valueItem.className = `px-6 py-1.5 hover:bg-gray-100 cursor-pointer flex items-center justify-between ${isActive ? 'bg-blue-50' : ''}`;
                    valueItem.onclick = (e) => {
                        e.stopPropagation();
                        this.toggleFilter(field.key, value, e);
                    };
                    
                    const valueLabel = document.createElement('span');
                    valueLabel.className = `text-sm ${isActive ? 'text-blue-700 font-medium' : 'text-gray-700'}`;
                    valueLabel.textContent = value;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = isActive;
                    checkbox.className = 'rounded border-gray-300 text-blue-600 focus:ring-blue-500';
                    checkbox.onclick = (e) => {
                        e.stopPropagation();
                    };
                    checkbox.onchange = (e) => {
                        e.stopPropagation();
                        this.toggleFilter(field.key, value, e);
                    };
                    
                    valueItem.appendChild(valueLabel);
                    valueItem.appendChild(checkbox);
                    valuesContainer.appendChild(valueItem);
                });
                
                container.appendChild(valuesContainer);
            }
        });
    }

    isRecipeVisible(recipe) {
        // If no filters are active, all recipes are visible
        let hasActiveFilters = false;
        Object.values(this.activeFilters).forEach(set => {
            if (set.size > 0) hasActiveFilters = true;
        });
        
        if (!hasActiveFilters) return true;
        
        // Check each filter type
        for (const [field, activeValues] of Object.entries(this.activeFilters)) {
            if (activeValues.size > 0) {
                const recipeValue = recipe[field] || '';
                if (!activeValues.has(recipeValue)) {
                    return false;
                }
            }
        }
        
        return true;
    }
}


// Recipe Manager class
class RecipeManager {
    constructor() {
        this.recipeDatabase = {};
        this.currentSortOrder = 'alphabetical';
        this.scrollPositions = {
            recipeList: 0,
            recipeForm: 0
        };
    }

    generateId() {
        return 'recipe_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    getFilteredRecipes() {
        let recipes = this.getSortedRecipes();
        
        // Apply filters
        if (app.filterManager) {
            recipes = recipes.filter(recipe => app.filterManager.isRecipeVisible(recipe));
        }
        
        return recipes;
    }

    saveDatabase() {
        const dataToSave = {
            recipes: this.recipeDatabase,
            scrollPositions: this.scrollPositions,
            currentFormState: app.formManager.getFormState()
        };
        localStorage.setItem('recipeDatabase', JSON.stringify(dataToSave));
    }

    loadDatabase() {
        const stored = localStorage.getItem('recipeDatabase');
        if (stored) {
            try {
                const data = JSON.parse(stored);
                
                if (data.recipes) {
                    this.recipeDatabase = data.recipes || {};
                    this.scrollPositions = data.scrollPositions || { recipeList: 0, recipeForm: 0 };
                    
                    if (data.currentFormState) {
                        window.pendingFormState = data.currentFormState;
                    }
                } else {
                    this.recipeDatabase = data;
                    this.scrollPositions = { recipeList: 0, recipeForm: 0 };
                }
            } catch (e) {
                this.recipeDatabase = {};
                this.scrollPositions = { recipeList: 0, recipeForm: 0 };
            }
        }
    }

    loadSortPreference() {
        const savedSort = localStorage.getItem('recipeSortOrder');
        if (savedSort) {
            this.currentSortOrder = savedSort;
            document.querySelector(`input[name="sortOrder"][value="${savedSort}"]`).checked = true;
        }
    }

    changeSortOrder(order) {
        this.currentSortOrder = order;
        localStorage.setItem('recipeSortOrder', order);
        app.uiManager.renderRecipeList();
    }

    getSortedRecipes() {
        let recipes = Object.values(this.recipeDatabase);
        
        switch(this.currentSortOrder) {
            case 'alphabetical':
                recipes.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
                break;
                
            case 'person':
                recipes.sort((a, b) => {
                    const providerA = a.provider || 'Zzz';
                    const providerB = b.provider || 'Zzz';
                    const providerCompare = providerA.localeCompare(providerB);
                    if (providerCompare !== 0) return providerCompare;
                    return (a.title || '').localeCompare(b.title || '');
                });
                break;
                
            case 'source':
                recipes.sort((a, b) => {
                    const refA = a.reference || 'Zzz';
                    const refB = b.reference || 'Zzz';
                    const refCompare = refA.localeCompare(refB);
                    if (refCompare !== 0) return refCompare;
                    
                    const pageA = a.pageNumber || 99999;
                    const pageB = b.pageNumber || 99999;
                    if (pageA !== pageB) return pageA - pageB;
                    
                    return (a.title || '').localeCompare(b.title || '');
                });
                break;
                
            case 'date':
                recipes.sort((a, b) => {
                    const dateA = a.createdAt || '1970-01-01';
                    const dateB = b.createdAt || '1970-01-01';
                    const dateCompare = dateB.localeCompare(dateA);
                    if (dateCompare !== 0) return dateCompare;
                    return (a.title || '').localeCompare(b.title || '');
                });
                break;
        }
        
        return recipes;
    }

    // ADD THIS METHOD - This was missing or not properly implemented
    getFilteredRecipes() {
        let recipes = this.getSortedRecipes();
        
        // Apply filters if FilterManager exists
        if (app.filterManager) {
            recipes = recipes.filter(recipe => app.filterManager.isRecipeVisible(recipe));
        }
        
        return recipes;
    }

    saveRecipe() {
        let id = document.getElementById('recipeId').value;
        const isNew = !id;
        
        if (!id) {
            id = this.generateId();
            document.getElementById('recipeId').value = id;
        }
        
        const recipe = {
            id: id,
            title: document.getElementById('title').value.trim(),
            servings: document.getElementById('servings').value.trim()
        };
        
        const provider = document.getElementById('provider').value.trim();
        if (provider) recipe.provider = provider;
        
        const reference = document.getElementById('reference').value.trim();
        if (reference) recipe.reference = reference;
        
        const pageNumber = document.getElementById('pageNumber').value.trim();
        if (pageNumber) recipe.pageNumber = parseInt(pageNumber);
        
        const category = document.getElementById('category').value.trim();
        if (category) recipe.category = category;
        
        const meal = document.getElementById('meal').value.trim();
        if (meal) recipe.meal = meal;
        
        const cuisine = document.getElementById('cuisine').value.trim();
        if (cuisine) recipe.cuisine = cuisine;
        
        const description = document.getElementById('description').value.trim();
        if (description) recipe.description = description;
        
        const image = document.getElementById('image').value.trim();
        if (image) recipe.image = image;
        
        const ingredientsText = document.getElementById('ingredients').value;
        if (ingredientsText) {
            recipe.ingredients = app.dataParser.parseIngredients(ingredientsText);
        }
        
        const instructionsText = document.getElementById('instructions').value;
        if (instructionsText) {
            recipe.instructions = app.dataParser.parseInstructions(instructionsText);
        }
        
        recipe.createdAt = this.recipeDatabase[id]?.createdAt || new Date().toISOString().split('T')[0];
        
        this.recipeDatabase[id] = recipe;
        this.saveDatabase();
        
        document.getElementById('recipeId').value = id;
        app.uiManager.updateRecipeIdDisplay();
        app.uiManager.updateDeleteButtonVisibility();
        app.uiManager.renderRecipeList();
        app.uiManager.updateDataLists();
        app.uiManager.updateActiveRecipe();
        app.historyManager.saveToHistory();
        
        app.uiManager.showNotification(`Oppskrift "${recipe.title}" ${isNew ? 'opprettet' : 'oppdatert'}!`, 'success');
    }

    deleteRecipe() {
        const id = document.getElementById('recipeId').value;
        if (!id || !this.recipeDatabase[id]) return;
        
        const title = this.recipeDatabase[id].title;
        
        if (confirm(`Er du sikker p√• at du vil slette "${title}"?`)) {
            delete this.recipeDatabase[id];
            this.saveDatabase();
            app.uiManager.renderRecipeList();
            app.formManager.clearForm();
            app.uiManager.showNotification(`Oppskrift "${title}" slettet!`, 'warning');
        }
    }

    editRecipe(id) {
        const recipe = this.recipeDatabase[id];
        if (!recipe) return;
        
        this.saveScrollPositions();
        
        app.formManager.populateForm(recipe, true);
        app.uiManager.updateActiveRecipe();
        
        this.restoreScrollPositions();
        
        app.uiManager.showNotification(`Redigerer "${recipe.title}"`, 'info');
        
        app.historyManager.history = [];
        app.historyManager.historyIndex = -1;
        app.historyManager.saveToHistory();
    }

    saveScrollPositions() {
        const listContainer = document.getElementById('recipeList');
        const formContainer = document.getElementById('recipeFormContainer');
        
        this.scrollPositions.recipeList = listContainer ? listContainer.scrollTop : 0;
        this.scrollPositions.recipeForm = formContainer ? formContainer.scrollTop : 0;
        
        this.saveDatabase();
    }

    restoreScrollPositions() {
        const listContainer = document.getElementById('recipeList');
        const formContainer = document.getElementById('recipeFormContainer');
        
        if (listContainer) {
            listContainer.scrollTop = this.scrollPositions.recipeList;
        }
        if (formContainer) {
            formContainer.scrollTop = this.scrollPositions.recipeForm;
        }
    }
}

// UI Manager class
class UIManager {
    showNotification(message, type = 'success') {
        const container = document.getElementById('notificationContainer');
        const notification = document.createElement('div');
        
        const bgColor = type === 'success' ? 'bg-green-500' : 
                        type === 'error' ? 'bg-red-500' : 
                        type === 'warning' ? 'bg-yellow-500' : 'bg-blue-500';
        
        const icon = type === 'success' ? '‚úì' : 
                    type === 'error' ? '‚úï' : 
                    type === 'warning' ? '‚ö†' : '‚Ñπ';
        
        notification.className = `notification pointer-events-auto flex items-center gap-3 px-4 py-3 rounded-lg shadow-lg text-white ${bgColor} max-w-md`;
        notification.innerHTML = `
            <span class="text-xl">${icon}</span>
            <span class="flex-1">${message}</span>
        `;
        
        container.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.add('hiding');
            setTimeout(() => {
                container.removeChild(notification);
            }, 300);
        }, 3000);
    }

    updateRecipeIdDisplay() {
        const recipeId = document.getElementById('recipeId').value;
        const display = document.getElementById('recipeIdDisplay');
        const regenerateBtn = document.getElementById('regenerateIdBtn');
        
        if (recipeId) {
            display.textContent = `ID: ${recipeId}`;
            regenerateBtn.classList.remove('hidden');
        } else {
            display.textContent = '';
            regenerateBtn.classList.add('hidden');
        }
    }

    updateDeleteButtonVisibility() {
        const recipeId = document.getElementById('recipeId').value;
        const deleteBtn = document.getElementById('deleteBtn');
        if (recipeId && app.recipeManager.recipeDatabase[recipeId]) {
            deleteBtn.classList.remove('hidden');
        } else {
            deleteBtn.classList.add('hidden');
        }
    }

    updateActiveRecipe() {
        const currentId = document.getElementById('recipeId').value;
        const items = document.querySelectorAll('.recipe-item');
        items.forEach(item => {
            if (item.dataset.recipeId === currentId) {
                item.classList.add('bg-amber-400', 'hover:bg-amber-500');
                item.classList.remove('bg-gray-50', 'hover:bg-gray-100');
                item.querySelector('.recipe-title').classList.add('text-white');
                item.querySelector('.recipe-title').classList.remove('text-gray-800');
                item.querySelector('.recipe-meta').classList.add('text-amber-100');
                item.querySelector('.recipe-meta').classList.remove('text-gray-500');
            } else {
                item.classList.remove('bg-amber-400', 'hover:bg-amber-500');
                item.classList.add('bg-gray-50', 'hover:bg-gray-100');
                item.querySelector('.recipe-title').classList.remove('text-white');
                item.querySelector('.recipe-title').classList.add('text-gray-800');
                item.querySelector('.recipe-meta').classList.remove('text-amber-100');
                item.querySelector('.recipe-meta').classList.add('text-gray-500');
            }
        });
    }

    renderRecipeList() {
        const list = document.getElementById('recipeList');
        const recipes = app.recipeManager.getFilteredRecipes(); // Changed from getSortedRecipes
        
        const currentId = document.getElementById('recipeId').value;
        
        list.innerHTML = '';
        recipes.forEach(recipe => {
            const item = document.createElement('div');
            const isActive = recipe.id === currentId;
            item.className = `recipe-item p-3 rounded-lg cursor-pointer transition-all duration-200 hover:translate-x-1 ${
                isActive ? 'bg-amber-400 hover:bg-amber-500' : 'bg-gray-50 hover:bg-gray-100'
            }`;
            item.dataset.recipeId = recipe.id;
            
            let metaInfo = [];
            if (app.recipeManager.currentSortOrder === 'person' && recipe.provider) {
                metaInfo.push(`üë§ ${recipe.provider}`);
            } else if (app.recipeManager.currentSortOrder === 'source' && recipe.reference) {
                let sourceInfo = `üìñ ${recipe.reference}`;
                if (recipe.pageNumber) sourceInfo += ` s.${recipe.pageNumber}`;
                metaInfo.push(sourceInfo);
            } else if (app.recipeManager.currentSortOrder === 'date' && recipe.createdAt) {
                metaInfo.push(`üìÖ ${recipe.createdAt}`);
            } else {
                if (recipe.category) metaInfo.push(recipe.category);
                if (recipe.meal) metaInfo.push(recipe.meal);
            }
            
            item.innerHTML = `
                <div class="font-medium recipe-title ${isActive ? 'text-white' : 'text-gray-800'}">${recipe.title}</div>
                <div class="text-xs recipe-meta ${isActive ? 'text-amber-100' : 'text-gray-500'}">
                    ${metaInfo.join(' ‚Ä¢ ')}
                </div>
            `;
            item.onclick = () => app.recipeManager.editRecipe(recipe.id);
            list.appendChild(item);
        });
        
        // Update count with filtered count
        const totalRecipes = Object.keys(app.recipeManager.recipeDatabase).length;
        const filteredCount = recipes.length;
        const countText = totalRecipes === filteredCount ? 
            `${totalRecipes} oppskrifter` : 
            `${filteredCount} av ${totalRecipes} oppskrifter`;
        document.getElementById('recipeCount').textContent = countText;
    }

    updateDataLists() {
        const categories = new Set(Config.DEFAULT_CATEGORIES);
        const meals = new Set(Config.DEFAULT_MEALS);
        const cuisines = new Set(Config.DEFAULT_CUISINES);
        
        Object.values(app.recipeManager.recipeDatabase).forEach(recipe => {
            if (recipe.category) categories.add(recipe.category);
            if (recipe.meal) meals.add(recipe.meal);
            if (recipe.cuisine) cuisines.add(recipe.cuisine);
        });
        
        document.getElementById('categoryList').innerHTML = Array.from(categories).map(c => `<option value="${c}">`).join('');
        document.getElementById('mealList').innerHTML = Array.from(meals).map(m => `<option value="${m}">`).join('');
        document.getElementById('cuisineList').innerHTML = Array.from(cuisines).map(c => `<option value="${c}">`).join('');
    }

    previewRecipe() {
        const title = document.getElementById('title').value.trim();
        if (!title) {
            this.showNotification('Vennligst fyll inn minst en tittel', 'warning');
            return;
        }
        
        let html = `<h3 class="text-xl font-bold text-gray-800">${title}</h3>`;
        
        const provider = document.getElementById('provider').value.trim();
        const reference = document.getElementById('reference').value.trim();
        const pageNumber = document.getElementById('pageNumber').value.trim();
        
        if (provider || reference) {
            html += '<div class="text-sm text-gray-600">';
            if (provider) html += `${provider}s oppskrift`;
            if (provider && reference) html += ' ‚Ä¢ ';
            if (reference) {
                html += `üìñ ${reference}`;
                if (pageNumber) html += ` s.${pageNumber}`;
            }
            html += '</div>';
        }
        
        const servings = document.getElementById('servings').value.trim();
        if (servings) html += `<p class="text-sm text-gray-600 mb-2">Porsjoner: ${servings}</p>`;
        
        const meta = [];
        const category = document.getElementById('category').value.trim();
        if (category) meta.push(`Kategori: ${category}`);
        const meal = document.getElementById('meal').value.trim();
        if (meal) meta.push(`M√•ltid: ${meal}`);
        const cuisine = document.getElementById('cuisine').value.trim();
        if (cuisine) meta.push(`Kj√∏kken: ${cuisine}`);
        if (meta.length) html += `<p class="text-xs text-gray-500 mb-3">${meta.join(' ‚Ä¢ ')}</p>`;
        
        const description = document.getElementById('description').value.trim();
        if (description) html += `<p class="text-gray-700 mb-4">${description}</p>`;
        
        const imageFilename = document.getElementById('image').value.trim();
        if (imageFilename) {
            const imagePath = app.imageManager.getImagePath(imageFilename);
            html += `<img src="${imagePath}" class="w-full h-48 object-cover rounded-lg mb-4">`;
        }
        
        const ingredientsText = document.getElementById('ingredients').value.trim();
        if (ingredientsText) {
            const ingredients = app.dataParser.parseIngredients(ingredientsText);
            html += '<h4 class="font-semibold text-gray-800 mb-2">Ingredienser:</h4>';
            html += '<div class="mb-4">';
            ingredients.forEach(item => {
                if (typeof item === 'string') {
                    html += `<div class="text-gray-700">‚Ä¢ ${item}</div>`;
                } else if (item.group) {
                    html += `<div class="font-medium text-gray-700 mt-2">${item.group}:</div>`;
                    item.items.forEach(ing => {
                        html += `<div class="text-gray-700 ml-4">‚Ä¢ ${ing}</div>`;
                    });
                }
            });
            html += '</div>';
        }
        
        const instructionsText = document.getElementById('instructions').value.trim();
        if (instructionsText) {
            const instructions = app.dataParser.parseInstructions(instructionsText);
            html += '<h4 class="font-semibold text-gray-800 mb-2">Fremgangsm√•te:</h4>';
            html += '<div class="space-y-1">';
            
            let stepNumber = 1;
            
            instructions.forEach((item, index) => {
                if (typeof item === 'string') {
                    html += `<div class="text-gray-700">${stepNumber}. ${item}</div>`;
                    stepNumber++;
                } else if (item.group && item.steps) {
                    html += `<div class="font-medium text-gray-700 mt-4 mb-2">${item.group}:</div>`;
                    item.steps.forEach(step => {
                        html += `<div class="text-gray-700 pl-6">${stepNumber}. ${step}</div>`;
                        stepNumber++;
                    });
                }
            });
            
            html += '</div>';
        }
        
        document.getElementById('previewContent').innerHTML = html;
        document.getElementById('previewModal').classList.remove('hidden');
    }

    closePreview() {
        document.getElementById('previewModal').classList.add('hidden');
    }
}

// Form Manager class
class FormManager {
    getFormState() {
        return {
            recipeId: document.getElementById('recipeId').value,
            title: document.getElementById('title').value,
            provider: document.getElementById('provider').value,
            reference: document.getElementById('reference').value,
            pageNumber: document.getElementById('pageNumber').value,
            servings: document.getElementById('servings').value,
            category: document.getElementById('category').value,
            meal: document.getElementById('meal').value,
            cuisine: document.getElementById('cuisine').value,
            description: document.getElementById('description').value,
            image: document.getElementById('image').value,
            ingredients: document.getElementById('ingredients').value,
            instructions: document.getElementById('instructions').value
        };
    }

    applyFormState(state) {
        app.historyManager.isApplyingHistory = true;
        document.getElementById('recipeId').value = state.recipeId || '';
        document.getElementById('title').value = state.title || '';
        document.getElementById('provider').value = state.provider || '';
        document.getElementById('reference').value = state.reference || '';
        document.getElementById('pageNumber').value = state.pageNumber || '';
        document.getElementById('servings').value = state.servings || '';
        document.getElementById('category').value = state.category || '';
        document.getElementById('meal').value = state.meal || '';
        document.getElementById('cuisine').value = state.cuisine || '';
        document.getElementById('description').value = state.description || '';
        document.getElementById('image').value = state.image || '';
        document.getElementById('ingredients').value = state.ingredients || '';
        document.getElementById('instructions').value = state.instructions || '';
        app.imageManager.updateImagePreview();
        app.uiManager.updateRecipeIdDisplay();
        app.uiManager.updateDeleteButtonVisibility();
        app.historyManager.isApplyingHistory = false;
    }

    populateForm(recipe, populateAllFields = false) {
        if (populateAllFields) {
            const completeRecipe = {
                id: '',
                title: '',
                provider: '',
                reference: '',
                pageNumber: '',
                servings: '',
                category: '',
                meal: '',
                cuisine: '',
                description: '',
                image: '',
                ingredients: '',
                instructions: '',
                ...recipe
            };
            recipe = completeRecipe;
        }
        
        if ('id' in recipe) {
            document.getElementById('recipeId').value = recipe.id || '';
        }
        
        if ('title' in recipe) {
            document.getElementById('title').value = recipe.title || '';
        }
        
        if ('provider' in recipe) {
            document.getElementById('provider').value = recipe.provider || '';
        }
        
        if ('reference' in recipe) {
            document.getElementById('reference').value = recipe.reference || '';
        }
        
        if ('pageNumber' in recipe) {
            document.getElementById('pageNumber').value = recipe.pageNumber || '';
        }
        
        if ('servings' in recipe) {
            document.getElementById('servings').value = recipe.servings || '';
        }
        
        if ('category' in recipe) {
            document.getElementById('category').value = recipe.category || '';
        }
        
        if ('meal' in recipe) {
            document.getElementById('meal').value = recipe.meal || '';
        }
        
        if ('cuisine' in recipe) {
            document.getElementById('cuisine').value = recipe.cuisine || '';
        }
        
        if ('description' in recipe) {
            document.getElementById('description').value = recipe.description || '';
        }
        
        if ('image' in recipe) {
            document.getElementById('image').value = recipe.image || '';
            app.imageManager.updateImagePreview();
        }
        
        app.uiManager.updateRecipeIdDisplay();
        app.uiManager.updateDeleteButtonVisibility();
        
        if ('ingredients' in recipe && recipe.ingredients) {
            let ingredientText = '';
            
            if (Array.isArray(recipe.ingredients)) {
                recipe.ingredients.forEach((item, index) => {
                    if (typeof item === 'string') {
                        if (!item.startsWith('//')) {
                            ingredientText += item + '\n';
                        }
                    } else if (item.group && item.items) {
                        ingredientText += `---${item.group}---\n`;
                        ingredientText += item.items.join('\n') + '\n';
                        
                        const nextItem = recipe.ingredients[index + 1];
                        if (nextItem && typeof nextItem === 'string') {
                            ingredientText += '---\n';
                        }
                    }
                });
            } else if (typeof recipe.ingredients === 'object') {
                const keys = Object.keys(recipe.ingredients);
                keys.forEach((groupName, index) => {
                    const items = recipe.ingredients[groupName];
                    if (Array.isArray(items) && items.length > 0) {
                        const formattedGroupName = groupName.charAt(0).toUpperCase() + groupName.slice(1);
                        ingredientText += `---${formattedGroupName}---\n`;
                        ingredientText += items.join('\n') + '\n';
                    }
                });
            }
            
            document.getElementById('ingredients').value = ingredientText.trim();
        } else if (populateAllFields) {
            document.getElementById('ingredients').value = '';
        }
        
        if ('instructions' in recipe && recipe.instructions) {
            let instructionText = '';
            
            if (Array.isArray(recipe.instructions)) {
                recipe.instructions.forEach((item, index) => {
                    if (typeof item === 'string') {
                        if (!item.startsWith('//')) {
                            instructionText += item + '\n';
                        }
                    } else if (item.group && item.steps) {
                        instructionText += `---${item.group}---\n`;
                        instructionText += item.steps.join('\n') + '\n';
                        
                        const nextItem = recipe.instructions[index + 1];
                        if (nextItem && typeof nextItem === 'string') {
                            instructionText += '---\n';
                        }
                    }
                });
            } else if (typeof recipe.instructions === 'string') {
                instructionText = recipe.instructions;
            } else if (typeof recipe.instructions === 'object' && !Array.isArray(recipe.instructions)) {
                const keys = Object.keys(recipe.instructions);
                keys.forEach((groupName, index) => {
                    const steps = recipe.instructions[groupName];
                    if (Array.isArray(steps) && steps.length > 0) {
                        const formattedGroupName = groupName.charAt(0).toUpperCase() + groupName.slice(1);
                        instructionText += `---${formattedGroupName}---\n`;
                        instructionText += steps.join('\n') + '\n';
                    }
                });
            }
            
            document.getElementById('instructions').value = instructionText.trim();
        } else if (populateAllFields) {
            document.getElementById('instructions').value = '';
        }
    }

    clearForm() {
        app.recipeManager.saveScrollPositions();
        
        document.getElementById('recipeForm').reset();
        document.getElementById('recipeId').value = '';
        
        document.getElementById('imageLoadingState').classList.add('hidden');
        document.getElementById('imageErrorState').classList.add('hidden');
        document.getElementById('imageSuccessState').classList.add('hidden');
        
        app.uiManager.updateRecipeIdDisplay();
        app.uiManager.updateDeleteButtonVisibility();
        app.uiManager.updateActiveRecipe();
        
        app.recipeManager.restoreScrollPositions();
        
        app.historyManager.history = [];
        app.historyManager.historyIndex = -1;
        app.historyManager.saveToHistory();
    }

    parseJsonInput() {
        const jsonInput = document.getElementById('jsonPaste').value.trim();
        if (!jsonInput) return;
        
        try {
            let data;
            
            try {
                data = JSON.parse(jsonInput);
            } catch (e) {
                let cleanedInput = jsonInput;
                
                const wrapperMatch = cleanedInput.match(/^["\']?[\w_]+["\']?\s*:\s*(\{[\s\S]*\})\s*$/);
                if (wrapperMatch) {
                    cleanedInput = wrapperMatch[1];
                }
                
                try {
                    const jsObjectStr = cleanedInput
                        .replace(/(\w+):/g, '"$1":')
                        .replace(/:\s*'([^']*)'/g, ':"$1"')
                        .replace(/,\s*}/g, '}')
                        .replace(/,\s*]/g, ']');
                    
                    data = JSON.parse(jsObjectStr);
                } catch (parseError) {
                    data = eval('(' + cleanedInput + ')');
                }
            }
            
            const keys = Object.keys(data);
            if (keys.length === 1 && typeof data[keys[0]] === 'object' && !Array.isArray(data[keys[0]])) {
                data = data[keys[0]];
            }
            
            delete data.id;
            
            const currentId = document.getElementById('recipeId').value;
            if (currentId && app.recipeManager.recipeDatabase[currentId]) {
                data.id = currentId;
            }
            
            this.populateForm(data);
            document.getElementById('jsonPaste').value = '';
            app.uiManager.showNotification('JSON parsket! Gjennomg√• og lagre oppskriften.', 'success');
            app.historyManager.saveToHistory();
        } catch (e) {
            app.uiManager.showNotification('Ugyldig format: ' + e.message, 'error');
        }
    }

    processMultipleRecipes() {
        const jsonInput = document.getElementById('jsonPaste').value.trim();
        if (!jsonInput) {
            app.uiManager.showNotification('Lim inn JSON med oppskrifter f√∏rst', 'warning');
            return;
        }
        
        try {
            let data;
            
            try {
                data = JSON.parse(jsonInput);
            } catch (e) {
                let cleanedInput = jsonInput;
                
                const wrapperMatch = cleanedInput.match(/^["\']?[\w_]+["\']?\s*:\s*(\[[\s\S]*\])\s*$/);
                if (wrapperMatch) {
                    cleanedInput = wrapperMatch[1];
                }
                
                try {
                    const jsObjectStr = cleanedInput
                        .replace(/(\w+):/g, '"$1":')
                        .replace(/:\s*'([^']*)'/g, ':"$1"')
                        .replace(/,\s*}/g, '}')
                        .replace(/,\s*]/g, ']');
                    
                    data = JSON.parse(jsObjectStr);
                } catch (parseError) {
                    data = eval('(' + cleanedInput + ')');
                }
            }
            
            if (!Array.isArray(data)) {
                app.uiManager.showNotification('Input m√• v√¶re en array av oppskrifter', 'error');
                return;
            }
            
            let updatedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;
            const updatedRecipes = [];
            
            data.forEach((updateData, index) => {
                try {
                    if (!updateData.id) {
                        console.warn(`Recipe at index ${index} missing id field, skipping`);
                        skippedCount++;
                        return;
                    }
                    
                    if (!app.recipeManager.recipeDatabase[updateData.id]) {
                        console.warn(`Recipe with id "${updateData.id}" not found, skipping`);
                        skippedCount++;
                        return;
                    }
                    
                    const existingRecipe = app.recipeManager.recipeDatabase[updateData.id];
                    
                    const updatedRecipe = { ...existingRecipe };
                    let hasChanges = false;
                    
                    const updatableFields = [
                        'title', 'provider', 'reference', 'pageNumber', 'servings',
                        'category', 'meal', 'cuisine', 'description', 'image',
                        'ingredients', 'instructions'
                    ];
                    
                    updatableFields.forEach(field => {
                        if (field in updateData && updateData[field] !== undefined) {
                            if (field === 'ingredients' && updateData[field]) {
                                if (typeof updateData[field] === 'string') {
                                    updatedRecipe[field] = app.dataParser.parseIngredients(updateData[field]);
                                } else {
                                    updatedRecipe[field] = updateData[field];
                                }
                                hasChanges = true;
                            } else if (field === 'instructions' && updateData[field]) {
                                if (typeof updateData[field] === 'string') {
                                    updatedRecipe[field] = app.dataParser.parseInstructions(updateData[field]);
                                } else {
                                    updatedRecipe[field] = updateData[field];
                                }
                                hasChanges = true;
                            } else if (updateData[field] !== existingRecipe[field]) {
                                updatedRecipe[field] = updateData[field];
                                hasChanges = true;
                            }
                        }
                    });
                    
                    if (hasChanges) {
                        app.recipeManager.recipeDatabase[updateData.id] = updatedRecipe;
                        updatedRecipes.push(updatedRecipe.title || updateData.id);
                        updatedCount++;
                    }
                    
                } catch (err) {
                    console.error(`Error processing recipe at index ${index}:`, err);
                    errorCount++;
                }
            });
            
            if (updatedCount > 0) {
                app.recipeManager.saveDatabase();
                
                app.uiManager.renderRecipeList();
                app.uiManager.updateDataLists();
                
                const currentId = document.getElementById('recipeId').value;
                if (currentId && app.recipeManager.recipeDatabase[currentId]) {
                    this.populateForm(app.recipeManager.recipeDatabase[currentId]);
                    app.imageManager.updateImagePreview();
                }
            }
            
            document.getElementById('jsonPaste').value = '';
            
            let message = '';
            if (updatedCount > 0) {
                message = `${updatedCount} oppskrifter oppdatert`;
                if (updatedRecipes.length <= 3) {
                    message += `: ${updatedRecipes.join(', ')}`;
                }
            }
            if (skippedCount > 0) {
                if (message) message += '. ';
                message += `${skippedCount} hoppet over (mangler ID eller finnes ikke)`;
            }
            if (errorCount > 0) {
                if (message) message += '. ';
                message += `${errorCount} feil`;
            }
            
            if (updatedCount > 0) {
                app.uiManager.showNotification(message, 'success');
                const currentId = document.getElementById('recipeId').value;
                if (currentId) {
                    app.historyManager.saveToHistory();
                }
            } else if (skippedCount > 0 || errorCount > 0) {
                app.uiManager.showNotification(message, 'warning');
            } else {
                app.uiManager.showNotification('Ingen oppskrifter ble oppdatert', 'info');
            }
            
        } catch (e) {
            app.uiManager.showNotification('Ugyldig format: ' + e.message, 'error');
        }
    }

    async exportFormToClipboard() {
        const title = document.getElementById('title').value.trim();
        
        if (!title) {
            app.uiManager.showNotification('Vennligst fyll inn minst en tittel f√∏rst', 'warning');
            return;
        }
        
        const recipe = {
            title: title,
            servings: document.getElementById('servings').value.trim()
        };
        
        const provider = document.getElementById('provider').value.trim();
        if (provider) recipe.provider = provider;
        
        const reference = document.getElementById('reference').value.trim();
        if (reference) recipe.reference = reference;
        
        const pageNumber = document.getElementById('pageNumber').value.trim();
        if (pageNumber) recipe.pageNumber = parseInt(pageNumber);
        
        const category = document.getElementById('category').value.trim();
        if (category) recipe.category = category;
        
        const meal = document.getElementById('meal').value.trim();
        if (meal) recipe.meal = meal;
        
        const cuisine = document.getElementById('cuisine').value.trim();
        if (cuisine) recipe.cuisine = cuisine;
        
        const description = document.getElementById('description').value.trim();
        if (description) recipe.description = description;
        
        const image = document.getElementById('image').value.trim();
        if (image) recipe.image = image;
        
        const ingredientsText = document.getElementById('ingredients').value.trim();
        if (ingredientsText) {
            recipe.ingredients = app.dataParser.parseIngredients(ingredientsText);
        }
        
        const instructionsText = document.getElementById('instructions').value.trim();
        if (instructionsText) {
            recipe.instructions = app.dataParser.parseInstructions(instructionsText);
        }
        
        const jsonString = JSON.stringify(recipe, null, 2);
        
        try {
            await navigator.clipboard.writeText(jsonString);
            app.uiManager.showNotification('Oppskrift kopiert til utklippstavlen som JSON!', 'success');
        } catch (err) {
            const textarea = document.createElement('textarea');
            textarea.value = jsonString;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            app.uiManager.showNotification('Oppskrift kopiert til utklippstavlen som JSON!', 'success');
        }
    }

    async exportFormToClipboardCompact() {
        const title = document.getElementById('title').value.trim();
        
        if (!title) {
            app.uiManager.showNotification('Vennligst fyll inn minst en tittel f√∏rst', 'warning');
            return;
        }
        
        const generatedId = 'recipe_' + title
            .toLowerCase()
            .replace(/√¶/g, 'ae')
            .replace(/√∏/g, 'o')
            .replace(/√•/g, 'a')
            .replace(/[^\w\s-]/g, '')
            .replace(/\s+/g, '_')
            .replace(/-+/g, '_')
            .replace(/_+/g, '_')
            .replace(/^_|_$/g, '');
        
        const recipe = {
            id: generatedId,
            title: title,
            servings: document.getElementById('servings').value.trim()
        };
        
        const provider = document.getElementById('provider').value.trim();
        if (provider) recipe.provider = provider;
        
        const reference = document.getElementById('reference').value.trim();
        if (reference) recipe.reference = reference;
        
        const pageNumber = document.getElementById('pageNumber').value.trim();
        if (pageNumber) recipe.pageNumber = parseInt(pageNumber);
        
        const category = document.getElementById('category').value.trim();
        if (category) recipe.category = category;
        
        const meal = document.getElementById('meal').value.trim();
        if (meal) recipe.meal = meal;
        
        const cuisine = document.getElementById('cuisine').value.trim();
        if (cuisine) recipe.cuisine = cuisine;
        
        const description = document.getElementById('description').value.trim();
        if (description) recipe.description = description;
        
        const image = document.getElementById('image').value.trim();
        if (image) recipe.image = image;
        
        const ingredientsText = document.getElementById('ingredients').value.trim();
        if (ingredientsText) {
            recipe.ingredients = app.dataParser.parseIngredients(ingredientsText);
        }
        
        const instructionsText = document.getElementById('instructions').value.trim();
        if (instructionsText) {
            recipe.instructions = app.dataParser.parseInstructions(instructionsText);
        }
        
        const jsonString = JSON.stringify(recipe);
        
        try {
            await navigator.clipboard.writeText(jsonString);
            app.uiManager.showNotification('Oppskrift kopiert som enkeltlinje JSON!', 'success');
        } catch (err) {
            const textarea = document.createElement('textarea');
            textarea.value = jsonString;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            app.uiManager.showNotification('Oppskrift kopiert som enkeltlinje JSON!', 'success');
        }
    }

    regenerateId() {
        const currentTitle = document.getElementById('title').value.trim();
        
        if (!currentTitle) {
            app.uiManager.showNotification('Vennligst fyll inn en tittel f√∏rst', 'warning');
            return;
        }
        
        const currentId = document.getElementById('recipeId').value;
        
        if (currentId && app.recipeManager.recipeDatabase[currentId]) {
            if (!confirm('Dette vil endre oppskriftens ID. Den gamle IDen vil ikke lenger fungere. Er du sikker?')) {
                return;
            }
            
            const recipeData = app.recipeManager.recipeDatabase[currentId];
            
            const newId = app.recipeManager.generateId();
            
            app.recipeManager.recipeDatabase[newId] = { ...recipeData, id: newId };
            delete app.recipeManager.recipeDatabase[currentId];
            
            document.getElementById('recipeId').value = newId;
            
            app.recipeManager.saveDatabase();
            app.uiManager.renderRecipeList();
            app.uiManager.updateRecipeIdDisplay();
            app.uiManager.updateActiveRecipe();
            app.historyManager.saveToHistory();
            
            app.uiManager.showNotification('Ny ID generert!', 'success');
        } else {
            const newId = app.recipeManager.generateId();
            document.getElementById('recipeId').value = newId;
            app.uiManager.updateRecipeIdDisplay();
            app.historyManager.saveToHistory();
            app.uiManager.showNotification('Ny ID generert!', 'success');
        }
    }
}

// Data Parser class
class DataParser {
    parseIngredients(text) {
        const lines = text.trim().split('\n').filter(line => line.trim());
        const ingredients = [];
        let currentGroup = null;
        
        lines.forEach(line => {
            line = line.trim();
            if (line.startsWith('---') && line.endsWith('---')) {
                const content = line.slice(3, -3).trim();
                if (content === '' || content.toUpperCase() === 'END' || content.toUpperCase() === 'SLUTT') {
                    currentGroup = null;
                } else {
                    currentGroup = { group: content, items: [] };
                    ingredients.push(currentGroup);
                }
            } else if (line) {
                if (currentGroup) {
                    currentGroup.items.push(line);
                } else {
                    ingredients.push(line);
                }
            }
        });
        
        if (ingredients.every(item => typeof item === 'string')) {
            return ingredients;
        }
        
        return ingredients.filter(item => {
            if (typeof item === 'string') return true;
            return item.items && item.items.length > 0;
        });
    }

    parseInstructions(text) {
        const lines = text.trim().split('\n').filter(line => line.trim());
        const instructions = [];
        let currentGroup = null;
        
        lines.forEach(line => {
            line = line.trim();
            if (line.startsWith('---') && line.endsWith('---')) {
                const content = line.slice(3, -3).trim();
                if (content === '' || content.toUpperCase() === 'END' || content.toUpperCase() === 'SLUTT') {
                    currentGroup = null;
                } else {
                    currentGroup = { group: content, steps: [] };
                    instructions.push(currentGroup);
                }
            } else if (line) {
                if (currentGroup) {
                    currentGroup.steps.push(line);
                } else {
                    instructions.push(line);
                }
            }
        });
        
        if (instructions.every(item => typeof item === 'string')) {
            return instructions;
        }
        
        return instructions.filter(item => {
            if (typeof item === 'string') return true;
            return item.steps && item.steps.length > 0;
        });
    }
}

// History Manager class
class HistoryManager {
    constructor() {
        this.history = [];
        this.historyIndex = -1;
        this.isApplyingHistory = false;
    }

    saveToHistory() {
        if (this.isApplyingHistory) return;
        
        const currentState = app.formManager.getFormState();
        
        this.history = this.history.slice(0, this.historyIndex + 1);
        
        this.history.push(currentState);
        this.historyIndex++;
        
        if (this.history.length > 50) {
            this.history.shift();
            this.historyIndex--;
        }
        
        this.updateHistoryButtons();
        
        app.recipeManager.saveDatabase();
    }

    undo() {
        if (this.historyIndex > 0) {
            this.historyIndex--;
            app.formManager.applyFormState(this.history[this.historyIndex]);
            this.updateHistoryButtons();
            app.uiManager.updateActiveRecipe();
        }
    }

    redo() {
        if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++;
            app.formManager.applyFormState(this.history[this.historyIndex]);
            this.updateHistoryButtons();
            app.uiManager.updateActiveRecipe();
        }
    }

    updateHistoryButtons() {
        document.getElementById('undoBtn').disabled = this.historyIndex <= 0;
        document.getElementById('redoBtn').disabled = this.historyIndex >= this.history.length - 1;
    }
}

// Image Manager class
class ImageManager {
    constructor() {
        this.imageLoadTimeout = null;
    }

    getImagePath(filename) {
        if (!filename) return '';
        
        const extension = filename.split('.').pop().toLowerCase();
        
        const basePath = Config.IMAGE_PATHS[extension] || Config.IMAGE_PATHS['default'];
        
        return basePath + filename;
    }

    updateImagePreview() {
        const imageFilename = document.getElementById('image').value.trim();
        const loadingState = document.getElementById('imageLoadingState');
        const errorState = document.getElementById('imageErrorState');
        const successState = document.getElementById('imageSuccessState');
        const previewImg = document.getElementById('imagePreview');
        
        if (this.imageLoadTimeout) {
            clearTimeout(this.imageLoadTimeout);
        }
        
        loadingState.classList.add('hidden');
        errorState.classList.add('hidden');
        successState.classList.add('hidden');
        
        if (!imageFilename) {
            return;
        }
        
        const imagePath = this.getImagePath(imageFilename);
        
        loadingState.classList.remove('hidden');
        
        const testImg = new Image();
        
        this.imageLoadTimeout = setTimeout(() => {
            this.showImageError('Bildet tar for lang tid √• laste. Sjekk at filen eksisterer og pr√∏v igjen.');
            testImg.src = '';
        }, 10000);
        
        testImg.onload = () => {
            clearTimeout(this.imageLoadTimeout);
            loadingState.classList.add('hidden');
            previewImg.src = imagePath;
            successState.classList.remove('hidden');
        };
        
        testImg.onerror = () => {
            clearTimeout(this.imageLoadTimeout);
            const extension = imageFilename.split('.').pop().toLowerCase();
            const expectedPath = Config.IMAGE_PATHS[extension] || Config.IMAGE_PATHS['default'];
            
            let errorMsg = `Kunne ikke laste bildet "${imageFilename}". `;
            errorMsg += `Sjekk at filen eksisterer i mappen ${expectedPath}`;
            
            this.showImageError(errorMsg);
        };
        
        testImg.src = imagePath;
    }

    showImageError(message) {
        const loadingState = document.getElementById('imageLoadingState');
        const errorState = document.getElementById('imageErrorState');
        const successState = document.getElementById('imageSuccessState');
        const errorMessage = document.getElementById('imageErrorMessage');
        
        loadingState.classList.add('hidden');
        successState.classList.add('hidden');
        errorMessage.textContent = message;
        errorState.classList.remove('hidden');
    }

    refreshImage() {
        const imageFilename = document.getElementById('image').value.trim();
        if (!imageFilename) {
            app.uiManager.showNotification('Ingen bildefil √• oppdatere', 'warning');
            return;
        }
        
        const loadingState = document.getElementById('imageLoadingState');
        const errorState = document.getElementById('imageErrorState');
        const successState = document.getElementById('imageSuccessState');
        
        errorState.classList.add('hidden');
        successState.classList.add('hidden');
        loadingState.classList.remove('hidden');
        
        if (this.imageLoadTimeout) {
            clearTimeout(this.imageLoadTimeout);
        }
        
        const imagePath = this.getImagePath(imageFilename);
        const tempPath = imagePath + '?t=' + Date.now();
        
        const testImg = new Image();
        
        this.imageLoadTimeout = setTimeout(() => {
            this.showImageError('Bildet tar for lang tid √• laste. Sjekk at filen eksisterer og pr√∏v igjen.');
            testImg.src = '';
        }, 10000);
        
        testImg.onload = () => {
            clearTimeout(this.imageLoadTimeout);
            this.updateImagePreview();
        };
        
        testImg.onerror = () => {
            clearTimeout(this.imageLoadTimeout);
            this.updateImagePreview();
        };
        
        testImg.src = tempPath;
    }
}

// Import Export Manager class
class ImportExportManager {
    constructor() {
        this.pendingImportData = null;
    }

    toggleExportMenu() {
        const menu = document.getElementById('exportMenu');
        menu.classList.toggle('hidden');
        
        if (!menu.classList.contains('hidden')) {
            setTimeout(() => {
                document.addEventListener('click', this.closeExportMenu);
            }, 10);
        }
    }

    closeExportMenu(e) {
        const menu = document.getElementById('exportMenu');
        const button = event.target.closest('button');
        if (!button || !button.textContent.includes('Eksporter')) {
            menu.classList.add('hidden');
            document.removeEventListener('click', this.closeExportMenu);
        }
    }

    openImportModal() {
        document.getElementById('importModal').classList.remove('hidden');
        document.getElementById('deleteExistingRecipes').checked = false;
        document.getElementById('importFileInput').value = '';
        document.getElementById('selectedFileName').textContent = '';
        document.getElementById('confirmImportBtn').disabled = true;
        this.pendingImportData = null;
    }

    closeImportModal() {
        document.getElementById('importModal').classList.add('hidden');
        document.getElementById('importFileInput').value = '';
        this.pendingImportData = null;
    }

    selectImportFile() {
        document.getElementById('importFileInput').click();
    }

    performImport() {
        if (!this.pendingImportData) return;
        
        const deleteExisting = document.getElementById('deleteExistingRecipes').checked;
        
        try {
            const recipes = Array.isArray(this.pendingImportData) ? this.pendingImportData : [this.pendingImportData];
            
            if (deleteExisting) {
                app.recipeManager.recipeDatabase = {};
            }
            
            let newCount = 0;
            let updatedCount = 0;
            
            recipes.forEach(recipe => {
                if (recipe.title) {
                    if (recipe.id && app.recipeManager.recipeDatabase[recipe.id]) {
                        app.recipeManager.recipeDatabase[recipe.id] = recipe;
                        updatedCount++;
                    } else {
                        if (!recipe.id) {
                            recipe.id = app.recipeManager.generateId();
                        }
                        app.recipeManager.recipeDatabase[recipe.id] = recipe;
                        newCount++;
                    }
                }
            });
            
            app.recipeManager.saveDatabase();
            app.uiManager.renderRecipeList();
            app.uiManager.updateDataLists();
            
            let message = '';
            if (deleteExisting) {
                message = `Database slettet og ${newCount} oppskrifter importert!`;
            } else {
                if (newCount > 0 && updatedCount > 0) {
                    message = `${newCount} nye og ${updatedCount} oppdaterte oppskrifter!`;
                } else if (newCount > 0) {
                    message = `${newCount} nye oppskrifter importert!`;
                } else if (updatedCount > 0) {
                    message = `${updatedCount} oppskrifter oppdatert!`;
                } else {
                    message = 'Ingen oppskrifter importert.';
                }
            }
            
            app.uiManager.showNotification(message, 'success');
            this.closeImportModal();
        } catch (err) {
            app.uiManager.showNotification('Feil ved import: ' + err.message, 'error');
        }
    }

    convertImageExtensions(recipe) {
        const shouldConvert = document.getElementById('convertPngToJpg').checked;
        
        if (!shouldConvert || !recipe.image) {
            return recipe;
        }
        
        const modifiedRecipe = { ...recipe };
        
        if (modifiedRecipe.image.toLowerCase().endsWith('.png')) {
            modifiedRecipe.image = modifiedRecipe.image.replace(/\.png$/i, '.jpg');
        }
        
        return modifiedRecipe;
    }

    async exportDatabase(method) {
        const recipes = app.recipeManager.getFilteredRecipes();
        
        if (recipes.length === 0) {
            app.uiManager.showNotification('Ingen oppskrifter √• eksportere', 'warning');
            document.getElementById('exportMenu').classList.add('hidden');
            return;
        }
        
        // Check if filters are active
        let hasActiveFilters = false;
        Object.values(app.filterManager.activeFilters).forEach(set => {
            if (set.size > 0) hasActiveFilters = true;
        });
        
        const processedRecipes = recipes.map(recipe => this.convertImageExtensions(recipe));
        
        const compactJson = processedRecipes.map(recipe => 
            JSON.stringify(recipe)
        ).join(',\n');
        
        const jsonContent = '[\n' + compactJson + '\n]';
        
        if (method === 'clipboard') {
            try {
                await navigator.clipboard.writeText(jsonContent);
                const convertEnabled = document.getElementById('convertPngToJpg').checked;
                let message = hasActiveFilters ? 
                    `${recipes.length} filtrerte oppskrifter kopiert til utklippstavlen!` :
                    `${recipes.length} oppskrifter kopiert til utklippstavlen!`;
                
                if (convertEnabled) {
                    message += ` (.png ‚Üí .jpg konvertering aktivert)`;
                }
                
                app.uiManager.showNotification(message, 'success');
            } catch (err) {
                const textarea = document.createElement('textarea');
                textarea.value = jsonContent;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                const convertEnabled = document.getElementById('convertPngToJpg').checked;
                let message = hasActiveFilters ? 
                    `${recipes.length} filtrerte oppskrifter kopiert til utklippstavlen!` :
                    `${recipes.length} oppskrifter kopiert til utklippstavlen!`;
                
                if (convertEnabled) {
                    message += ` (.png ‚Üí .jpg konvertering aktivert)`;
                }
                
                app.uiManager.showNotification(message, 'success');
            }
        } else {
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            const dateStr = new Date().toISOString().split('T')[0];
            const filename = hasActiveFilters ? 
                `recipes_filtered_${dateStr}.json` : 
                `recipes_${dateStr}.json`;
            
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            const convertEnabled = document.getElementById('convertPngToJpg').checked;
            let message = hasActiveFilters ? 
                `${recipes.length} filtrerte oppskrifter eksportert til fil!` :
                `${recipes.length} oppskrifter eksportert til fil!`;
            
            if (convertEnabled) {
                message += ` (.png ‚Üí .jpg konvertering aktivert)`;
            }
            
            app.uiManager.showNotification(message, 'success');
        }
        
        document.getElementById('exportMenu').classList.add('hidden');
    }
}

// Template Manager class
class TemplateManager {
    getRecipeTemplate() {
        return {
            title: "Oppskriftens navn (P√ÖKREVD)",
            servings: "Antall porsjoner, f.eks: '4 porsjoner' eller '12 stk.' (P√ÖKREVD)",
            provider: "Farmor",
            reference: "Oppskriftsbok",
            pageNumber: "Sidenummer i kilden (VALGFRITT, tall)",
            category: "Kategori (VALGFRITT, f.eks: 'Br√∏d', 'Kake', 'Grateng', 'Suppe')",
            meal: "M√•ltidstype (VALGFRITT, f.eks: 'Frokost', 'Middag', 'Dessert', 'Snacks')",
            cuisine: "Kj√∏kkentype (VALGFRITT, f.eks: 'Norsk', 'Italiensk', 'Asiatisk')",
            description: "Beskrivelse av retten - smak, tekstur, n√•r den passer, tips (VALGFRITT men anbefalt)",
            ingredients: [
                "// For enkle oppskrifter, bruk array av strenger:",
                "500 g hvetemel",
                "2 dl melk",
                "// ELLER for grupperte ingredienser, bruk objekter:",
                {
                    group: "Deig",
                    items: ["500 g mel", "2 dl melk"]
                },
                {
                    group: "Fyll",
                    items: ["100 g sukker", "2 ss kanel"]
                }
            ],
            instructions: [
                "// For enkle oppskrifter, bruk array av strenger:",
                "F√∏rste steg i oppskriften",
                "Andre steg med klare instruksjoner",
                "// ELLER for grupperte instruksjoner, bruk objekter:",
                {
                    group: "Forberedelse",
                    steps: ["Forvarm ovnen til 180¬∞C", "Sm√∏r formen"]
                },
                {
                    group: "Tilberedning",
                    steps: ["Bland ingrediensene", "Hell i formen", "Stek i 25 minutter"]
                }
            ]
        };
    }

    async copyTemplate() {
        const template = this.getRecipeTemplate();
        const templateJson = JSON.stringify(template, null, 2);
        
        const fullTemplate = `Kan du lese og tolke den h√•ndskrevne oppskriften i det vedlagte bildet? Gi navn til denne chatten basert p√• oppskriftens tittel. Tolk s√• mye som mulig fra oppskrift og bruk kompliment√¶re kunnskap fra kjente oppskrifter fra norge p√• 60-80 tallet for √• v√¶re sikker p√• at vi setter opp oppskriften riktig. Start med √• summere hva som er lesbart fra oppskriften. Skriv s√• om hvilke kjente oppskrifter som kan passe med det vi vet. Moderniser s√• oppskriften ved √• bruke moderne m√•l og beskrivelser, men v√¶r s√• trofast til orginaloppskriften som mulig, nevn n√•r vi b√∏r avvike fra oppskriften og hvorfor. Folk var ofte mye mer erfarne p√• kj√∏kkenet og trengte mindre hjelp. N√•r du er ferdig med dette konverter oppskriften til et JSON objekt med formatet under. Om et personnavn er lagt til tittelen bruk dette som personen (I stedet for Farmor), og kilden er alltid Oppskriftsbok. Hent sidetall ut fra bildetittel. JSON FORMAT:

${templateJson}

VIKTIGE MERKNADER: - Tittel og porsjoner er P√ÖKREVD - I beskrivelsen skal vi ikke fokusere p√• n√•r retten er fra, men  hvilke type oppskrift det er, hva som er spesielt med den. Vanskelighetsgrad. Hvilke smaksprofil den har, hva den passer sammen med, og andre nyttige serveringstips. - Alle andre felt er valgfrie - Tips i instruksjoner markeres med "TIP: " i starten av linjen - Ingredienser og instruksjoner kan grupperes med objekter som vist i eksemplet - Moderniser gamle m√•l og beskrivelser - Er det 2 oppskrifter p√• siden lag 2 separate json objekter`;
        
        try {
            await navigator.clipboard.writeText(fullTemplate);
            app.uiManager.showNotification('Oppskriftmal kopiert til utklippstavlen! Bruk den med AI-systemer.', 'success');
        } catch (err) {
            const textarea = document.createElement('textarea');
            textarea.value = fullTemplate;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            app.uiManager.showNotification('Oppskriftmal kopiert til utklippstavlen!', 'success');
        }
    }

    async exportImagePrompt() {
        const title = document.getElementById('title').value.trim();
        const category = document.getElementById('category').value.trim();
        const meal = document.getElementById('meal').value.trim();
        const cuisine = document.getElementById('cuisine').value.trim();
        const description = document.getElementById('description').value.trim();
        const ingredientsText = document.getElementById('ingredients').value.trim();
        const instructionsText = document.getElementById('instructions').value.trim();
        
        if (!title) {
            app.uiManager.showNotification('Vennligst fyll inn minst en tittel f√∏rst', 'warning');
            return;
        }
        
        let formattedIngredients = '';
        if (ingredientsText) {
            const ingredients = app.dataParser.parseIngredients(ingredientsText);
            ingredients.forEach(item => {
                if (typeof item === 'string') {
                    formattedIngredients += item + ', ';
                } else if (item.group && item.items) {
                    formattedIngredients += item.group + ': ' + item.items.join(', ') + '. ';
                }
            });
            formattedIngredients = formattedIngredients.trim().replace(/,$/, '');
        }
        
        let formattedInstructions = '';
        if (instructionsText) {
            const instructions = app.dataParser.parseInstructions(instructionsText);
            const instructionsList = [];
            instructions.forEach(item => {
                if (typeof item === 'string') {
                    instructionsList.push(item);
                } else if (item.group && item.steps) {
                    instructionsList.push(...item.steps);
                }
            });
            formattedInstructions = instructionsList.join('. ');
        }
        
        const aiPrompt = `The name of this chat should be: "Bilde av ${title || 'Not specified'}"
        
    Generate a high-quality advertisement image for a food presentation. The image should be a close-up shot at a 40-degree angle of a well-decorated and dramatically lit table, where the ready food product is the main focus point. Use welcoming colors that give a cozy, presenting vibe. Create a professional food photography style image with beautiful lighting and composition. Pay close attention to the dishs ingredients and procedure and typical design when composing the image.

    Recipe title: ${title || 'Not specified'}
    Description: ${description || 'Not specified'}
    Category: ${category || 'Not specified'} | Meal: ${meal || 'Not specified'} | Cuisine: ${cuisine || 'Not specified'}
    Ingredients: ${formattedIngredients || 'Not specified'}
    Instructions: ${formattedInstructions || 'Not specified'}

    The final dish should look appetizing, fresh, and professionally plated. Include appropriate table settings, garnishes, and background elements that complement the dish without overwhelming it. The lighting should be warm and inviting, highlighting the textures and colors of the food. The image should be widescreen. The image should contain no recipes and no text.`;
        
        try {
            await navigator.clipboard.writeText(aiPrompt);
            app.uiManager.showNotification('Bildeprompt kopiert til utklippstavlen!', 'success');
        } catch (err) {
            const textarea = document.createElement('textarea');
            textarea.value = aiPrompt;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            app.uiManager.showNotification('Bildeprompt kopiert til utklippstavlen!', 'success');
        }
    }
}

// Taxonomy Manager class
class TaxonomyManager {
    constructor() {
        this.currentField = null;
        this.currentPage = 1;
        this.itemsPerPage = 20;
        this.pendingChanges = {}; // {oldValue: newValue}
        this.individualChanges = {}; // {recipeId: {field: newValue}}
        this.expandedValues = new Set();
    }

    openModal() {
        document.getElementById('taxonomyModal').classList.remove('hidden');
        document.getElementById('taxonomyFieldSelect').value = '';
        document.getElementById('taxonomyContent').innerHTML = '';
        document.getElementById('taxonomyStats').textContent = '';
        document.getElementById('taxonomyPagination').classList.add('hidden');
        this.pendingChanges = {};
        this.individualChanges = {};
        this.expandedValues.clear();
        this.updatePendingChangesDisplay();
    }

    closeModal() {
        if (Object.keys(this.pendingChanges).length > 0 || Object.keys(this.individualChanges).length > 0) {
            if (!confirm('Du har ulagrede endringer. Er du sikker p√• at du vil lukke?')) {
                return;
            }
        }
        document.getElementById('taxonomyModal').classList.add('hidden');
        this.resetChanges();
    }

    resetChanges() {
        this.pendingChanges = {};
        this.individualChanges = {};
        this.expandedValues.clear();
        
        // Update pending changes display to hide the yellow box
        this.updatePendingChangesDisplay();
        
        // Refresh the view if a field is selected
        if (this.currentField) {
            this.renderFieldValues();
        }
    }


    loadField(field) {
        this.currentField = field;
        this.currentPage = 1;
        this.renderFieldValues();
    }

    getUniqueValues() {
        if (!this.currentField) return [];
        
        const valueCount = {};
        const recipes = Object.values(app.recipeManager.recipeDatabase);
        
        recipes.forEach(recipe => {
            let value = recipe[this.currentField];
            if (value && value.trim()) {
                value = value.trim();
                // Apply pending changes
                if (this.pendingChanges[value]) {
                    value = this.pendingChanges[value];
                }
                // Apply individual changes
                if (this.individualChanges[recipe.id] && this.individualChanges[recipe.id][this.currentField] !== undefined) {
                    value = this.individualChanges[recipe.id][this.currentField];
                }
                
                if (value) {
                    valueCount[value] = (valueCount[value] || 0) + 1;
                }
            }
        });
        
        return Object.entries(valueCount).sort((a, b) => a[0].localeCompare(b[0]));
    }

    renderFieldValues() {
        const container = document.getElementById('taxonomyContent');
        const values = this.getUniqueValues();
        
        // Update stats
        document.getElementById('taxonomyStats').textContent = `${values.length} unike verdier`;
        
        // Pagination
        const totalPages = Math.ceil(values.length / this.itemsPerPage);
        const startIdx = (this.currentPage - 1) * this.itemsPerPage;
        const endIdx = Math.min(startIdx + this.itemsPerPage, values.length);
        const pageValues = values.slice(startIdx, endIdx);
        
        container.innerHTML = '';
        
        pageValues.forEach(([value, count]) => {
            const isExpanded = this.expandedValues.has(value);
            const hasPendingChange = Object.keys(this.pendingChanges).find(k => this.pendingChanges[k] === value);
            
            const valueItem = document.createElement('div');
            valueItem.className = `taxonomy-value-item border rounded-lg p-3 ${hasPendingChange ? 'taxonomy-change' : ''}`;
            valueItem.dataset.value = value;
            
            // Main value row
            const mainRow = document.createElement('div');
            mainRow.className = 'flex items-center justify-between';
            
            const leftSection = document.createElement('div');
            leftSection.className = 'flex items-center gap-3 flex-1';
            
            const valueDisplay = document.createElement('div');
            valueDisplay.className = 'flex items-center gap-2 cursor-pointer flex-1';
            valueDisplay.onclick = () => this.toggleRecipeList(value);
            
            const valueText = document.createElement('span');
            valueText.className = 'font-medium text-gray-800';
            valueText.textContent = value;
            
            const countBadge = document.createElement('span');
            countBadge.className = 'text-xs bg-gray-200 text-gray-600 px-2 py-1 rounded';
            countBadge.textContent = `${count} ${count === 1 ? 'oppskrift' : 'oppskrifter'}`;
            
            valueDisplay.appendChild(valueText);
            valueDisplay.appendChild(countBadge);
            
            if (hasPendingChange) {
                const changeIndicator = document.createElement('span');
                changeIndicator.className = 'text-xs text-orange-600 ml-2';
                changeIndicator.textContent = `‚Üê ${hasPendingChange}`;
                valueDisplay.appendChild(changeIndicator);
            }
            
            leftSection.appendChild(valueDisplay);
            
            const renameBtn = document.createElement('button');
            renameBtn.className = 'text-gray-600 hover:text-gray-800 transition';
            renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
            renameBtn.onclick = () => this.startRename(value, valueItem);
            
            mainRow.appendChild(leftSection);
            mainRow.appendChild(renameBtn);
            
            valueItem.appendChild(mainRow);
            
            // Recipe list (hidden by default)
            if (isExpanded) {
                const recipeList = this.createRecipeList(value);
                valueItem.appendChild(recipeList);
            }
            
            container.appendChild(valueItem);
        });
        
        this.renderPagination(totalPages);
    }

    createRecipeList(value) {
        const listContainer = document.createElement('div');
        listContainer.className = 'mt-3 pt-3 border-t taxonomy-recipes-list custom-scroll';
        
        const recipes = Object.values(app.recipeManager.recipeDatabase).filter(recipe => {
            let fieldValue = recipe[this.currentField];
            
            // Check for pending bulk rename
            if (this.pendingChanges[fieldValue]) {
                fieldValue = this.pendingChanges[fieldValue];
            }
            
            // Check for individual changes
            if (this.individualChanges[recipe.id] && this.individualChanges[recipe.id][this.currentField] !== undefined) {
                fieldValue = this.individualChanges[recipe.id][this.currentField];
            }
            
            return fieldValue === value;
        });
        
        // Get fresh unique values for suggestions after any changes
        const allValues = new Set();
        
        // Add default values based on field type
        if (this.currentField === 'category') {
            Config.DEFAULT_CATEGORIES.forEach(c => allValues.add(c));
        } else if (this.currentField === 'meal') {
            Config.DEFAULT_MEALS.forEach(m => allValues.add(m));
        } else if (this.currentField === 'cuisine') {
            Config.DEFAULT_CUISINES.forEach(c => allValues.add(c));
        }
        
        // Add all current values from database
        Object.values(app.recipeManager.recipeDatabase).forEach(r => {
            if (r[this.currentField]) {
                allValues.add(r[this.currentField]);
            }
        });
        
        // Add any pending new values
        Object.values(this.pendingChanges).forEach(v => {
            if (v) allValues.add(v);
        });
        
        // Add any individual change values
        Object.values(this.individualChanges).forEach(changes => {
            if (changes[this.currentField]) {
                allValues.add(changes[this.currentField]);
            }
        });
        
        recipes.forEach(recipe => {
            const recipeRow = document.createElement('div');
            recipeRow.className = 'flex items-center gap-2 py-2 px-2 hover:bg-gray-50';
            recipeRow.dataset.recipeId = recipe.id;
            
            const recipeTitle = document.createElement('span');
            recipeTitle.className = 'text-sm text-gray-700 flex-shrink-0';
            recipeTitle.textContent = recipe.title;
            
            const fieldInput = document.createElement('input');
            fieldInput.type = 'text';
            fieldInput.className = 'flex-1 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-blue-500 focus:border-blue-500';
            fieldInput.value = this.individualChanges[recipe.id]?.[this.currentField] ?? 
                            this.pendingChanges[recipe[this.currentField]] ?? 
                            recipe[this.currentField] ?? '';
            
            // Add datalist for suggestions
            const datalistId = `datalist_${recipe.id}_${this.currentField}`;
            fieldInput.setAttribute('list', datalistId);
            
            const datalist = document.createElement('datalist');
            datalist.id = datalistId;
            
            // Sort and add all values as options
            Array.from(allValues).sort().forEach(v => {
                const option = document.createElement('option');
                option.value = v;
                datalist.appendChild(option);
            });
            
            const actionButtons = document.createElement('div');
            actionButtons.className = 'flex gap-1 opacity-0 transition';
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'text-green-600 hover:text-green-800 text-sm';
            confirmBtn.innerHTML = '<i class="fas fa-check"></i>';
            confirmBtn.onclick = () => this.confirmIndividualChange(recipe.id, fieldInput.value);
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'text-red-600 hover:text-red-800 text-sm';
            cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
            cancelBtn.onclick = () => this.cancelIndividualChange(recipe.id, fieldInput);
            
            actionButtons.appendChild(confirmBtn);
            actionButtons.appendChild(cancelBtn);
            
            fieldInput.oninput = () => {
                const originalValue = recipe[this.currentField] ?? '';
                if (fieldInput.value !== originalValue && fieldInput.value !== this.pendingChanges[originalValue]) {
                    actionButtons.classList.remove('opacity-0');
                } else {
                    actionButtons.classList.add('opacity-0');
                }
            };
            
            recipeRow.appendChild(recipeTitle);
            recipeRow.appendChild(fieldInput);
            recipeRow.appendChild(datalist);
            recipeRow.appendChild(actionButtons);
            
            listContainer.appendChild(recipeRow);
        });
        
        return listContainer;
    }

    toggleRecipeList(value) {
        if (this.expandedValues.has(value)) {
            this.expandedValues.delete(value);
        } else {
            this.expandedValues.add(value);
        }
        this.renderFieldValues();
    }

    startRename(value, container) {
        const mainRow = container.querySelector('.flex');
        const valueDisplay = mainRow.querySelector('.flex-1');
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'flex-1 px-2 py-1 border border-gray-300 rounded focus:ring-blue-500 focus:border-blue-500';
        input.value = value;
        
        const actionButtons = document.createElement('div');
        actionButtons.className = 'flex gap-2';
        
        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'text-green-600 hover:text-green-800';
        confirmBtn.innerHTML = '<i class="fas fa-check"></i>';
        confirmBtn.onclick = () => this.confirmRename(value, input.value);
        
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'text-red-600 hover:text-red-800';
        cancelBtn.innerHTML = '<i class="fas fa-times"></i>';
        cancelBtn.onclick = () => this.renderFieldValues();
        
        actionButtons.appendChild(confirmBtn);
        actionButtons.appendChild(cancelBtn);
        
        mainRow.innerHTML = '';
        mainRow.appendChild(input);
        mainRow.appendChild(actionButtons);
        
        input.focus();
        input.select();
        
        input.onkeydown = (e) => {
            if (e.key === 'Enter') {
                this.confirmRename(value, input.value);
            } else if (e.key === 'Escape') {
                this.renderFieldValues();
            }
        };
    }

    confirmRename(oldValue, newValue) {
        if (newValue && newValue !== oldValue) {
            // Check if there's already a pending change for this value
            const existingChangeKey = Object.keys(this.pendingChanges).find(k => this.pendingChanges[k] === oldValue);
            if (existingChangeKey) {
                // Update the chain
                this.pendingChanges[existingChangeKey] = newValue;
            } else {
                this.pendingChanges[oldValue] = newValue;
            }
            this.updatePendingChangesDisplay();
        }
        this.renderFieldValues();
    }

    confirmIndividualChange(recipeId, newValue) {
        if (!this.individualChanges[recipeId]) {
            this.individualChanges[recipeId] = {};
        }
        this.individualChanges[recipeId][this.currentField] = newValue;
        this.updatePendingChangesDisplay();
        
        // Refresh to update suggestions in other inputs
        this.renderFieldValues();
    }

    cancelIndividualChange(recipeId, input) {
        const recipe = app.recipeManager.recipeDatabase[recipeId];
        input.value = recipe[this.currentField] ?? '';
        
        if (this.individualChanges[recipeId]) {
            delete this.individualChanges[recipeId][this.currentField];
            if (Object.keys(this.individualChanges[recipeId]).length === 0) {
                delete this.individualChanges[recipeId];
            }
        }
        this.updatePendingChangesDisplay();
        this.renderFieldValues();
    }

    renderPagination(totalPages) {
        const paginationContainer = document.getElementById('taxonomyPagination');
        
        if (totalPages <= 1) {
            paginationContainer.classList.add('hidden');
            return;
        }
        
        paginationContainer.classList.remove('hidden');
        paginationContainer.innerHTML = '';
        
        // Previous button
        const prevBtn = document.createElement('button');
        prevBtn.className = `px-3 py-1 rounded ${this.currentPage === 1 ? 'bg-gray-200 text-gray-400 cursor-not-allowed' : 'bg-gray-200 hover:bg-gray-300'}`;
        prevBtn.textContent = '‚Üê';
        prevBtn.disabled = this.currentPage === 1;
        prevBtn.onclick = () => {
            if (this.currentPage > 1) {
                this.currentPage--;
                this.renderFieldValues();
            }
        };
        paginationContainer.appendChild(prevBtn);
        
        // Page numbers
        for (let i = 1; i <= totalPages; i++) {
            if (i === 1 || i === totalPages || (i >= this.currentPage - 2 && i <= this.currentPage + 2)) {
                const pageBtn = document.createElement('button');
                pageBtn.className = `px-3 py-1 rounded ${i === this.currentPage ? 'bg-blue-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`;
                pageBtn.textContent = i;
                pageBtn.onclick = () => {
                    this.currentPage = i;
                    this.renderFieldValues();
                };
                paginationContainer.appendChild(pageBtn);
            } else if (i === this.currentPage - 3 || i === this.currentPage + 3) {
                const dots = document.createElement('span');
                dots.className = 'px-2';
                dots.textContent = '...';
                paginationContainer.appendChild(dots);
            }
        }
        
        // Next button
        const nextBtn = document.createElement('button');
        nextBtn.className = `px-3 py-1 rounded ${this.currentPage === totalPages ? 'bg-gray-200 text-gray-400 cursor-not-allowed' : 'bg-gray-200 hover:bg-gray-300'}`;
        nextBtn.textContent = '‚Üí';
        nextBtn.disabled = this.currentPage === totalPages;
        nextBtn.onclick = () => {
            if (this.currentPage < totalPages) {
                this.currentPage++;
                this.renderFieldValues();
            }
        };
        paginationContainer.appendChild(nextBtn);
    }

    updatePendingChangesDisplay() {
        const container = document.getElementById('taxonomyPendingChanges');
        const list = document.getElementById('taxonomyChangesList');
        const saveBtn = document.getElementById('taxonomySaveBtn');
        const resetBtn = document.getElementById('taxonomyResetBtn');
        
        const hasChanges = Object.keys(this.pendingChanges).length > 0 || Object.keys(this.individualChanges).length > 0;
        
        if (!hasChanges) {
            container.classList.add('hidden');
            saveBtn.disabled = true;
            resetBtn.disabled = true;
            list.innerHTML = '';
            return;
        }
        
        container.classList.remove('hidden');
        saveBtn.disabled = false;
        resetBtn.disabled = false;
        
        list.innerHTML = '';
        
        // Show bulk renames
        Object.entries(this.pendingChanges).forEach(([oldValue, newValue]) => {
            const item = document.createElement('li');
            item.innerHTML = `<strong>Gruppeendring:</strong> "${oldValue}" ‚Üí "${newValue}"`;
            list.appendChild(item);
        });
        
        // Show individual changes
        Object.entries(this.individualChanges).forEach(([recipeId, fields]) => {
            const recipe = app.recipeManager.recipeDatabase[recipeId];
            if (recipe) {
                Object.entries(fields).forEach(([field, newValue]) => {
                    const oldValue = recipe[field] || '(tom)';
                    const item = document.createElement('li');
                    item.innerHTML = `<strong>${recipe.title}:</strong> "${oldValue}" ‚Üí "${newValue}"`;
                    list.appendChild(item);
                });
            }
        });
    }

    saveChanges() {
        if (!confirm('Er du sikker p√• at du vil anvende alle endringer? Dette kan ikke angres.')) {
            return;
        }
        
        let changedCount = 0;
        
        // Apply bulk renames first
        Object.entries(this.pendingChanges).forEach(([oldValue, newValue]) => {
            Object.values(app.recipeManager.recipeDatabase).forEach(recipe => {
                if (recipe[this.currentField] === oldValue) {
                    recipe[this.currentField] = newValue;
                    changedCount++;
                }
            });
        });
        
        // Apply individual changes
        Object.entries(this.individualChanges).forEach(([recipeId, fields]) => {
            const recipe = app.recipeManager.recipeDatabase[recipeId];
            if (recipe) {
                Object.entries(fields).forEach(([field, newValue]) => {
                    if (recipe[field] !== newValue) {
                        recipe[field] = newValue;
                        changedCount++;
                    }
                });
            }
        });
        
        // Save database
        app.recipeManager.saveDatabase();
        
        // Update UI
        app.uiManager.renderRecipeList();
        app.uiManager.updateDataLists();
        
        // If current form is affected, reload it
        const currentId = document.getElementById('recipeId').value;
        if (currentId && app.recipeManager.recipeDatabase[currentId]) {
            const recipe = app.recipeManager.recipeDatabase[currentId];
            if (this.individualChanges[currentId]?.[this.currentField] !== undefined || 
                this.pendingChanges[recipe[this.currentField]]) {
                app.formManager.populateForm(recipe);
            }
        }
        
        // Clear changes
        this.pendingChanges = {};
        this.individualChanges = {};
        this.expandedValues.clear();
        
        // Update pending changes display to hide the yellow box
        this.updatePendingChangesDisplay();
        
        // Refresh the field values to show updated data
        if (this.currentField) {
            this.renderFieldValues();
        }
        
        // Update stats
        const values = this.getUniqueValues();
        document.getElementById('taxonomyStats').textContent = `${values.length} unike verdier`;
        
        app.uiManager.showNotification(`${changedCount} endringer lagret!`, 'success');
    }
}

// Main Application class
class RecipeApp {
    constructor() {
        this.recipeManager = new RecipeManager();
        this.uiManager = new UIManager();
        this.formManager = new FormManager();
        this.dataParser = new DataParser();
        this.historyManager = new HistoryManager();
        this.imageManager = new ImageManager();
        this.importExportManager = new ImportExportManager();
        this.templateManager = new TemplateManager();
        this.taxonomyManager = new TaxonomyManager();
        this.filterManager = new FilterManager(); // Add this line
    }

    init() {
        this.recipeManager.loadDatabase();
        this.recipeManager.loadSortPreference();
        this.uiManager.renderRecipeList();
        this.uiManager.updateDataLists();
        
        if (window.pendingFormState) {
            setTimeout(() => {
                this.formManager.applyFormState(window.pendingFormState);
                this.uiManager.updateActiveRecipe();
                this.imageManager.updateImagePreview();
                delete window.pendingFormState;
                
                setTimeout(() => {
                    this.recipeManager.restoreScrollPositions();
                }, 50);
            }, 100);
        } else {
            setTimeout(() => {
                this.recipeManager.restoreScrollPositions();
            }, 100);
        }
        
        this.historyManager.saveToHistory();
        
        // Set up event listeners
        document.getElementById('recipeForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.recipeManager.saveRecipe();
        });
        
        document.getElementById('previewModal').addEventListener('click', function(e) {
            if (e.target === this) {
                app.uiManager.closePreview();
            }
        });
        
        document.getElementById('importModal').addEventListener('click', function(e) {
            if (e.target === this) {
                app.importExportManager.closeImportModal();
            }
        });
        
        document.getElementById('taxonomyFieldSelect').addEventListener('change', (e) => {
            const field = e.target.value;
            if (field) {
                this.taxonomyManager.loadField(field);
            } else {
                document.getElementById('taxonomyContent').innerHTML = '';
                document.getElementById('taxonomyStats').textContent = '';
                document.getElementById('taxonomyPagination').classList.add('hidden');
            }
        });
        
        document.getElementById('importFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('selectedFileName').textContent = file.name;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    this.importExportManager.pendingImportData = JSON.parse(e.target.result);
                    document.getElementById('confirmImportBtn').disabled = false;
                    
                    const recipes = Array.isArray(this.importExportManager.pendingImportData) ? 
                        this.importExportManager.pendingImportData : [this.importExportManager.pendingImportData];
                    const validRecipes = recipes.filter(r => r.title);
                    document.getElementById('selectedFileName').textContent = 
                        `${file.name} (${validRecipes.length} oppskrifter)`;
                } catch (err) {
                    this.uiManager.showNotification('Ugyldig JSON fil: ' + err.message, 'error');
                    document.getElementById('confirmImportBtn').disabled = true;
                }
            };
            reader.readAsText(file);
        });
    }
}

// Create and initialize the application
const app = new RecipeApp();
app.init();
</script>
</body>
</html>